<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">














<meta name="description" content="Ascen的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Ascen的羽毛">
<meta property="og:url" content="http://ascen.me/blog/page/2/index.html">
<meta property="og:site_name" content="Ascen的羽毛">
<meta property="og:description" content="Ascen的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ascen的羽毛">
<meta name="twitter:description" content="Ascen的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ascen.me/blog/page/2/"/>





  <title>Ascen的羽毛</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ascen的羽毛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/首页" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/关于我" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/归档" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/07/08/runloop_learning_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/07/08/runloop_learning_summary/" itemprop="url">RunLoop学习总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-08T23:36:12+08:00">
                2016-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>很久之前就看了一次YY的文章，没看懂。后来又看了sunny的视频和叶孤城的直播的视频，找了很多资料，对RunLoop也越来越清晰，然后又看了两三次YY的文章，虽然还没完全看懂，不得不说写的非常好，帮助很大。还有官方文档，学到了很多东西。还有就是github上的一些demo，文中一些代码别人写过了，我就直接拿过来了。文中一些结论也是取自大神的文章或者视频。非常感谢这些前辈大神们的分享吧！！</p>
<h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h3><p>RunLoop其实就是一种处理事件、消息的机制被面向对象化，它就是一个对象。其实它的本质就是一个do-while循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    //如果有事件/消息，就处理</span><br><span class="line">	//没事件/消息或者都处理完了就沉睡</span><br><span class="line">&#125; while(1)</span><br></pre></td></tr></table></figure>
<h3 id="NSRunloop和CFRunloop"><a href="#NSRunloop和CFRunloop" class="headerlink" title="NSRunloop和CFRunloop"></a>NSRunloop和CFRunloop</h3><p><code>NSRunLoop</code>是对<code>CFRunLoop</code>的封装，使之更面向对象化。我们一般在<code>NSRunLoop</code>层面上操作。<code>CFRunLoop</code>基于C语言，从属于<code>CoreFoundation</code>(开源)。</p>
<p>官方文档里对<code>CFRunLoop</code>的解释很好，它建立任务来监测着输入源(事件源，事件/消息)和准备好处理输入源的时候调度管理，输入源包括用户输入的设备，网络连接，周期性或者延迟的事件，还有异步的回调等。</p>
<h3 id="RunLoop的结构组成"><a href="#RunLoop的结构组成" class="headerlink" title="RunLoop的结构组成"></a>RunLoop的结构组成</h3><p>一个RunLoop可以监测三个对象，<code>Sources</code>, <code>Timers</code>, <code>Observers</code>，如图</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-05_RunLoop_0.png" alt="RunLoop"></p>
<p>图来自YY的文章，这个图很棒</p>
<p>其实是一个RunLoop对象可以包含一个或者多个Mode，这个Mode可以说是一种模式，一种配置。而Mode又包含着输入源（事件源）Source，观察者Observer，和计时器Timer和其他一些信息。</p>
<h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a><code>CFRunLoopMode</code></h3><p>Mode决定了RunLoop在什么时候处理什么事情，在某个Mode在某个时候能做什么不能做什么，在某个Mode某个时候只能做什么。<br>切换Mode需要先推出RunLoop再重新进入。</p>
<p>Mode有几种</p>
<ul>
<li>DefaultMode，<code>CFRunLoop</code>的是<code>kCFRunLoopDefaultMode</code>，<code>NSRunLoop</code>的是<code>NSDefaultRunLoopMode</code>，这是默认的mode，即APP平常的状态</li>
<li>UITrackingRunLoopMode，追踪scrollView滑动的状态，当有scrollView滑动的时候RunLoop会切换到该mode下，滑动结束再切换到其他mode</li>
<li>UIInitializationRunLoopMode，这个是私有的，在APP启动时到显示第一个界面期间会进入这个mode</li>
<li>NSRunLoopCommonModes，这个是Mode集合，自定义或者若干个集合，默认是包含了defaultMode和trackingMode</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
</ul>
<p>这里先说一个例子，例如我们创建的NSTimer对象在运行时碰到有scrollView的空间滑动的时候是默认不会继续计时的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tiktok) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">- (void)tiktok</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;,self.count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/7%E6%9C%88-05-2016%2009-14-14.gif" alt="defaultMode"></p>
<p>那是因为用scheduleTime…这个方法，timer默认被添加到了RunLoop的defaultMode，而滑动tableView的时候RunLoop切换到了trackingMode所以停止了。</p>
<p>解决方法就是把timer添加到当前RunLoop的UITrackingRunLoopMode或者NSRunLoopCommonModes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要添加一句</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span><br><span class="line">//或者</span><br><span class="line">//[[NSRunLoop currentRunLoop] addTimer:timer NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/7%E6%9C%88-05-2016%2009-19-29.gif" alt="UITrackingRunLoopMode"></p>
<h5 id="Mode的结构"><a href="#Mode的结构" class="headerlink" title="Mode的结构"></a>Mode的结构</h5><p><code>CFRunLoopMode</code>是一个<code>struct</code>，最主要是<code>Source</code>、<code>Timer</code>和<code>Observer</code>，这些被称为<code>mode item</code>，还有一些其他信息，例如name，就是指上面的defaultMode或者trackingMode的名字，还有一些线程锁标志信息等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Mode的名字</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Source就两个</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Observer数组</span></span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Timer数组</span></span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还有其他的一些信息</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h3><p>输入源(input source)是指用户的操作事件（例如点击屏幕）或者网络端口接收到的信息等。而一个CFRunLoopSource对象就是跑在RunLoop上输入源的抽象概念，Source可以说是用户操作的事件、消息和RunLoop的中间层。</p>
<p>有两种Source</p>
<ul>
<li>Source0，被APP所管理，处理内部事件，如UIEvent、CFSocket</li>
<li>Source1，被RunLoop和内核所管理，由Mach port驱动,如CFMachPort、CFMessagePort<br>这里已经涉及到很底层的东西了，查了下Mach port，很底层，太少资料，大概了解到一点是用来通信的通道，端口，这个还有待研究</li>
</ul>
<h3 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h3><p>这个就是观察者，同来用来接收各种回调(callbakcs)。一个Observer一次只能被一个RunLoop注册。当RunLoop的状态切换的时候Observer可以观察到</p>
<p>这个是RunLoop的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry  = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们来测试一下，创建一个Observer来观察RunLoop的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Observer，观察RunLoop的所有状态</span><br><span class="line">//这里打印出来的数字是上面struct的数字X的2^X</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">       NSLog(@&quot;RunLoop状态-%zd&quot;, activity);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">   //注意CF对象要释放</span><br><span class="line">   CFRelease(observer);</span><br></pre></td></tr></table></figure>
<p>然后查看打印</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-05_22:57:57.jpg" alt="2016-07-05_22:57:57.jpg"></p>
<p>后面的数字即刚才RunLoop的状态，对比struct可以看出，APP一运行就先进入RunLoop，然后2/4切换，即处理Source和Timer然后是32，即将进入睡眠状态，再64，即将从睡眠状态中醒来…然后循环两三次到最后32，即将进入睡眠状态，这就是一个APP打开的时候然后没给任何动作</p>
<p>接下来我滑动一下tableView，来看一下打印</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-05_23:20:51.jpg" alt="2016-07-05_23:20:51.jpg"></p>
<p>先醒过来，处理Source和Timer，然后有个128（即对应上面的2^7)，即将退出RunLoop，这是意料之中，因为我滑动tableView把mode切换到了trackingMode，而切换Mode的时候需要先退出mode再从新进入，等松开手后最终状态又变成32，睡眠状态</p>
<p>这也很符合刚开始的do-while循环，一有事件/消息处理就处理，不然就进入睡眠</p>
<h3 id="RunLoop和线程的关系"><a href="#RunLoop和线程的关系" class="headerlink" title="RunLoop和线程的关系"></a>RunLoop和线程的关系</h3><p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。(直接取自YY的结论)</p>
<h3 id="RunLoop和Autorelease-Pool"><a href="#RunLoop和Autorelease-Pool" class="headerlink" title="RunLoop和Autorelease Pool"></a>RunLoop和Autorelease Pool</h3><p>UIkit通过RunLoopObserver在RunLoop两次Sleep间对Autorelease Pool进行Pop和Push将这次Loop中产生的Aotorelease对象释放</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="tableView滑动后再加载图片"><a href="#tableView滑动后再加载图片" class="headerlink" title="tableView滑动后再加载图片"></a>tableView滑动后再加载图片</h4><p>当一个tableView或者collectionView（这两个都是继承自scrollView)里面放了很多图片的时候并且要加载的时候，有一个优化的措施就是在滑动的时候不加载，在滑动完了之后再开始加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *downloadedImage = ...;</span><br><span class="line">self.imageView performSelector:@selector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]];</span><br></pre></td></tr></table></figure>
<p>(以上代码取自sunny的视频)</p>
<p>让setImage方法只在NSDefaultRunLoopMode里面运行，在滑动的时候进入trackingMode就不执行</p>
<p>还有更具体的实现可以看下这个github demo</p>
<p>虽然可以这样实现，但是我觉得使用性不强，我看了很多较常用的APP都没有这样实现，且当学习吧</p>
<h4 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]];</span><br></pre></td></tr></table></figure>
<h4 id="监测滑动卡顿"><a href="#监测滑动卡顿" class="headerlink" title="监测滑动卡顿"></a>监测滑动卡顿</h4><p>前面说到RunLoop会一直切换状态，我们要监测的是在处理Source的时候的时间，如果时间太长，则说明有可能卡顿了</p>
<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手. 为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</span><br><span class="line">&#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line"></span><br><span class="line">    // 记录状态值</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line"></span><br><span class="line">    // 发送信号</span><br><span class="line">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES, 0,&amp;runLoopObserverCallBack,&amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            if (st != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 5)</span><br><span class="line">                        continue;</span><br><span class="line">                    NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上带去取自<a href="https://github.com/suifengqjn/PerformanceMonitor" target="_blank" rel="noopener">https://github.com/suifengqjn/PerformanceMonitor</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>写的有点糟，只是一个小总结，感觉还是有好多不懂，还是要深入学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/07/02/singlton_learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/07/02/singlton_learning/" itemprop="url">单例模式探索</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-02T21:33:03+08:00">
                2016-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以前写OC中的单例很固定，一直都这样写，后来我就把它放在快捷代码块里面，只要输入singleton就直接输出这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)instance</span><br><span class="line">&#123;</span><br><span class="line">    static Class *sharedInstance = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一直这样写，并没有关注内部实现<br>这两天一直在复习C++，然后看到了C++的单例模式，发现内部实现还是挺有讲究的</p>
<p>先来看OC中的<br>这个方法刚学OC的时候就记下来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>官方文档的解释是，这个方法让block里面的代码在整个应用的生命周期里只执行一次，如果多线程同时调用，这个函数会让线程在block执行完之前都会同步地等待。只执行一次，顺带帮我们解决多线程问题，这是苹果帮我们封装好的，官方也建议用来写单例的方法！！</p>
<p>然后来看C++的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class Singleton &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">	Singleton();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态对象</span></span><br><span class="line">	<span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton* getInstance &#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">NULL</span>)</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们要把构造方法设置private，让别人无法调用构造方法<br>C++的静态对象和方法就像OC中的类的类对象和方法，类似在OC中是以+开头的方法<br>把instance和getInstance方法都设为静态，让类直接调用</p>
<p>这是一种实现方法，但是并没有考虑到线程安全<br>在getInstance()方法应该上锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static Singleton* getInstance &#123;</span><br><span class="line">	lock();	//这里不实现上锁方法，只是探讨单例模式</span><br><span class="line">	if(instance == NULL)</span><br><span class="line">		instance = new Singleton();</span><br><span class="line">	unlock();	//伪</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样是可行的，但是每次通过getInstance方法都会加上一个同步锁，加锁是一个非常耗时的操作，可以在没有必要的时候应该尽量避免。</p>
<p>进一步完善，当instance还没有创建的时候才需要加锁，等第二个线程上锁的时候再判断一次是否已经创建了instance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static Singleton* getInstance &#123;</span><br><span class="line">	if(instance == NULL)&#123;</span><br><span class="line">		lock();	//伪</span><br><span class="line">		if(instance == NULL)</span><br><span class="line">			instance = new Singleton();</span><br><span class="line">		unlock();	//伪</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，要保证只能从单例方法获取单例，不能赋值和拷贝<br>所以要声明赋值和拷贝方法，但是不实现</p>
<p>1<br>2<br>Singleton(const Singleton&amp;){};<br>Singleton&amp;operator=(const Singleton&amp;){};<br>在C++11也可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton(const Singleton&amp;) = delete;</span><br><span class="line">Singleton&amp;operator=(const Singleton&amp;) = delete;</span><br></pre></td></tr></table></figure>
<p>所以这是一种比较好的实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class Singleton &#123;</span><br><span class="line">private:</span><br><span class="line">	//构造函数</span><br><span class="line">	Singleton();</span><br><span class="line">	</span><br><span class="line">	//静态对象</span><br><span class="line">	static Singleton* instance;</span><br><span class="line">	</span><br><span class="line">	//赋值和拷贝方法</span><br><span class="line">	Singleton(const Singleton&amp;)&#123;&#125;;</span><br><span class="line">	Singleton&amp;operator=(const Singleton&amp;)&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	static Singleton* getInstance &#123;</span><br><span class="line">		if(instance == NULL)&#123;</span><br><span class="line">			lock();	//伪</span><br><span class="line">			if(instance == NULL)</span><br><span class="line">				instance = new Singleton();</span><br><span class="line">			unlock();	//伪</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于类的静态成员<br>在C++中，静态成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的，它们不是由类的构造函数初始化的，一般来说不能再累的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员，类似于全局变量，静态成员定义在任何函数之外，一旦被定义，将一直存在于成员的整个生命周期中<br>我们可以利用整个特性来写单例模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private:</span><br><span class="line">	Singleton();</span><br><span class="line">	static Singleton* instance;</span><br><span class="line">public:</span><br><span class="line">	static Singleton* getInstance&#123;</span><br><span class="line">		</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//然后在类外初始化</span><br><span class="line">Singleton* Singleton::instance = new Singleton();</span><br></pre></td></tr></table></figure>
<p>这种方法更加简洁，并且也是线程安全的，因为除了函数里面的静态变量，其他的静态变量都是在main函数之前就创建好了，单线程创建的，参考stackoverflow上的一个回答</p>
<p>在C#中可以直接在类内初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton &#123;</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">	private static Singleton instance = new Singleton();</span><br><span class="line">	public static Singleton getInstance &#123;</span><br><span class="line">		get</span><br><span class="line">		&#123;</span><br><span class="line">			return instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法比上一种二重锁的方法性能要更好<br>在C#中还有更好的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton &#123;</span><br><span class="line">	Singleton()&#123;&#125;</span><br><span class="line">	public static Singleton getInstance&#123;</span><br><span class="line">		get &#123;</span><br><span class="line">			return Nested.instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Class Nested&#123;</span><br><span class="line">		static Nested()&#123;&#125;</span><br><span class="line">		internal static readonly Singleton instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套类，当用到Nested类的时候才会调用构造方法创建instance<br>由于无法实现类内初始化instance，所以这种方法我还不知道C++怎么实现<br>以上方法都是参考自剑指Offer</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/06/20/im-app-developing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/06/20/im-app-developing/" itemprop="url">从零开发一个即时通讯APP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-20T17:25:31+08:00">
                2016-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是我的毕业设计。刚开始确定这个课题的时候是因为以前有稍微研究过一些XMPP协议，在这个基础上做起来应该不难。然后开始选技术的时候还有半年，我想为什么不从更底层做起呢！那就不用XMPP，当时接触过相关的即时通讯技术还有WebSocket，那为什么直接从更底层的Socket开始封装呢<br>服务端就用Go语言吧，用来做IM服务器和HTTP服务器都很好。</p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>既然是基于Socket，iOS端我并不准备中C语言的Socket开发封装起，而是使用一个第三方库<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>。XMPP的iOS framework也是从这个库开始封装。而Go语言的IM服务端则直接使用原生开发即可，无论是UDP还是TCP都已经封装的很好。<br>HTTP服务器使用的框架是Gin，已经相当成熟，可以用于大型服务端的开发了。<br>关于传输的数据格式，XMPP使用的是XML，但是体积太大，冗余过多不必要的数据，考虑了很久好像也没必要自己封装二进制的数据格式，我用的是Google的protocol buffer。HTTP服务器还是使用JSON。<br>我还需要存储客户端的IP地址，由于需要快速读写，我使用的是Redis。<br>AccessToken验证方式使用的是<a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Token（JWT)</a></p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>我的想法是使用UDP Socket来传输数据，至于为什么使用UDP呢，一开始的想法是UDP比TCP快，虽然可能会丢包但是可以试着优化。关于使用UDP来做IM这个想法也被一些大神喷过，但是这都是我自己的想法，就这样做着先。<br>使用UDP会丢包，所以我想需要一个回执机制，接收端收到了消息后就给发送端发送一个回执，这个回执包括这条消息的ID，如果发送方过一段时间还没有接受到回执的时候则重新发送。而且这个回执还不能丢，所以我使用TCP来发送回执。<br>UDP是无连接性的，还是要使用TCP来连接服务端，表明登录状态。所以TCP的作用是连接和发送回执。<br>具体思路是当客户端登录和重新连接的时候，客户端使用UDP Socket绑定端口，然后使用TCP Socket来发送UDP 地址给服务端，服务端把用户的ID和UDP地址存进Redis，等发送方发送的消息包含接收端的用户ID，服务端再从Redis取出接收方的UDP地址进行转发。<br>发送图片我是这样实现的，我会把图片上传到七牛云，发图片的URL来发送，接收端只需要使用URL来加载图片即可</p>
<h3 id="简单封装一个通讯协议"><a href="#简单封装一个通讯协议" class="headerlink" title="简单封装一个通讯协议"></a>简单封装一个通讯协议</h3><p>就叫简单的即时通讯协议，<code>Simple Instant Messaging Protocol</code>，简称SIMP<br>我想是基于连接的，所以一个用户对应一个 SIMPConnection，每一个SIMPConnection是一个单例，使用代理进行回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)connectionToRemoteHost:(NSString *)host port:(NSInteger)port forUser:(NSString *)userID;</span><br></pre></td></tr></table></figure>
<p>连接需要用户ID和服务器的地址和端口<br>在连接的时候就创建TCP和UDP Socket 进行连接，TCP Socket要发送连接的数据，包括UDP Socket的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)connectionToRemoteHost:(NSString *)host port:(NSInteger)port forUser:(NSString *)userID &#123;</span><br><span class="line">    self.host = host;</span><br><span class="line">    self.port = port;</span><br><span class="line">    self.userID = userID;</span><br><span class="line">    self.tcpSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)];</span><br><span class="line">    self.udpSocket = [[GCDAsyncUdpSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">    return [self connect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)connect &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        BOOL tcpSuccess = [self.tcpSocket connectToHost:self.host onPort:self.port error:&amp;error];</span><br><span class="line">        CheckError(@&quot;TCPSocketConnectToHost&quot;, &amp;error);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        BOOL udpSuccess = [self.udpSocket connectToHost:self.host onPort:self.port + 1 error:&amp;error];</span><br><span class="line">        </span><br><span class="line">        CheckError(@&quot;UDPSocketConnectToHost&quot;, &amp;error);</span><br><span class="line">        [self.udpSocket beginReceiving:&amp;error];</span><br><span class="line">        CheckError(@&quot;beginReceiving&quot;, &amp;error);</span><br><span class="line">        </span><br><span class="line">        [self sendConnectData];</span><br><span class="line">    return tcpSuccess &amp;&amp; udpSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有封装一个 <code>SIMPMessage</code> 里面包含protobuf的数据<br>我的protobuf数据是这样的，版本，消息的ID，时间，文字内容，图片URL，发送方的ID和接收方的ID，消息类型，图片的比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">message Message &#123;</span><br><span class="line">    float version = 1;</span><br><span class="line">    uint64 messageId = 2;</span><br><span class="line">	uint64 time = 3;</span><br><span class="line">	string content = 4;</span><br><span class="line">	string imageURL = 5;</span><br><span class="line">	string fromUser = 6;</span><br><span class="line">	string toUser = 7;</span><br><span class="line">	MessageType type = 8;</span><br><span class="line">	float imageScale = 9;</span><br><span class="line">	enum MessageType &#123;</span><br><span class="line">    	TEXT = 0;</span><br><span class="line">    	IMAGE = 1;</span><br><span class="line">    	AUDIO = 2;</span><br><span class="line">    	CONNECT = 3;</span><br><span class="line">    	RECEIPT = 4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有消息队列，群聊等一些我已经有想法但是还没实现的功能<br>架构<br>关于整个APP的流程如下<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-072550.jpg" alt=""></p>
<p>关于iOS端，使用了MVVM设计模式结合RAC，在Controller里面只需要组合一下视图和布局，绑定数据即可，把处理数据和大部分逻辑都放在了ViewModel里面，结构还算清晰。<br>关于数据管理，我使用了一个Redux思想的全局数据调度中心，实现了单向数据流，数据的持久化等。数据持久化用到了FMDB。但是大部分代码是一个大神写的，很屌。</p>
<h3 id="效果和下一步"><a href="#效果和下一步" class="headerlink" title="效果和下一步"></a>效果和下一步</h3><p>目前实现传输文字和图片，好友添加还是在后台添加（前端还没做），动态模块等。</p>
<p>登录<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-073418.jpg" alt=""></p>
<p>通讯录<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-073437.jpg" alt=""></p>
<p>详细资料<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-073506.jpg" alt=""></p>
<p>个人资料<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-073521.jpg" alt=""></p>
<p>聊天界面<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-06-23-073758.jpg" alt=""></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>先上传到了github，目前功能还不完善，还会持续开发<br><a href="https://github.com/AscenZ/Hey" target="_blank" rel="noopener">https://github.com/AscenZ/Hey</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/05/28/https_learning_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/05/28/https_learning_summary/" itemprop="url">HTTPS学习总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-28T00:28:53+08:00">
                2016-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>HTTPS对比HTTP就多了一个安全层SSL/TLS，具体就是验证服务端的证书和对内容进行加密。</p>
<p>先来看看HTTP和HTTPS的区别<br>我用AFN访问http下的httpbin.org/image/png<br>然后用Charles抓一下包，可以看到传输的图片<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="http的数据"><br>然后访问HTTPS下的<a href="https://httpbin.org/image/png" target="_blank" rel="noopener">https://httpbin.org/image/png</a><br>再抓包，看到数据是乱码，这就是加密过后的数据<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%872.png" alt="https的数据"></p>
<h3 id="关于加密算法"><a href="#关于加密算法" class="headerlink" title="关于加密算法"></a>关于加密算法</h3><p>1)对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p>
<p>2)非对称加密：非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>过程就像我们用github的时候也是这样，我们电脑这里生成私钥和公钥，公钥上传到github，私钥添加到我们电脑的ssh里，这样github给我们传输数据就是用我们上传的公钥来加密，我们获得数据后会用私钥去解密。</p>
<h3 id="什么是SSL-TLS"><a href="#什么是SSL-TLS" class="headerlink" title="什么是SSL/TLS"></a>什么是SSL/TLS</h3><p>TLS是 Transport Layer Security的缩写，传输层安全性协议，SSL是Secure Sockets Layer的缩写，安全sokects层协议。SSL/TLS有很多好处，强大的验证，算法灵活，容易部署和使用。缺点是增加处理器的负担，但是消耗的性能很小，对比安全性来说可以忽略不计。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>通信过程有四次握手。</p>
<ul>
<li>1、客户端发送请求，服务器返回公钥给客户端；</li>
<li>2、客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；</li>
<li>3、服务器收到后，利用私钥解开得到对称加密秘钥，保存；</li>
<li>4、之后的交互都使用对称加密后的数据进行交互。</li>
</ul>
<h3 id="HTTPS通信的优点"><a href="#HTTPS通信的优点" class="headerlink" title="HTTPS通信的优点"></a>HTTPS通信的优点</h3><p>1）客户端产生的密钥只有客户端和服务器端能得到；</p>
<p>2）加密的数据只有客户端和服务器端才能得到明文；</p>
<p>3）客户端到服务端的通信是安全的。</p>
<h4 id="如何获得证书"><a href="#如何获得证书" class="headerlink" title="如何获得证书"></a>如何获得证书</h4><h5 id="1-向CA申请证书"><a href="#1-向CA申请证书" class="headerlink" title="1.向CA申请证书"></a>1.向CA申请证书</h5><p>电子商务认证授权机构（CA, Certificate Authority），也称为电子商务认证中心，是负责发放和管理数字证书的权威机构。<br>这里就不细说了。</p>
<h5 id="2-自制证书"><a href="#2-自制证书" class="headerlink" title="2.自制证书"></a>2.自制证书</h5><p>还有一种方式就是自制证书，自制证书的证书是用OpenSSL生成的。OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并且已经在github上开源。</p>
<h3 id="OpenSSL的各种指令"><a href="#OpenSSL的各种指令" class="headerlink" title="OpenSSL的各种指令"></a>OpenSSL的各种指令</h3><p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%873.png" alt="OpenSSL"></p>
<p>自制证书的命令是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days XXX</span><br></pre></td></tr></table></figure>
<p>刚开始输入命令就会自动生成key.pem<br>输入命令后会让你输入密码、国家、省市、组织（公司）、名字等信息<br>输入完成便会生成证书cert.pem</p>
<p>关于命令的一些选项：</p>
<p>req 是证书请求和生成的程序</p>
<ul>
<li>-x509 一种证书标准</li>
<li>-newkey arg，arg是参数，例如rsa:2048是指生成2048位的rsa key</li>
<li>-keyout filename 输出的根证书文件名</li>
<li>-out filename 输出的标准证书文件吗</li>
<li>-day n 用X.509标准的话要指定验证多少天，默认30<br>预览cert.pem可以看到刚才输入的信息<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%874.png" alt="预览pem"></li>
</ul>
<p>pem可以转换成cer格式，可以用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer</span><br></pre></td></tr></table></figure>
<p>也可以双击 cert.pem，这样是导入到钥匙串，打开钥匙串便可导出cer格式的证书。</p>
<p>以上 部分自制证书资料参考的是stackoverflow的这个问题</p>
<h3 id="关于Security框架"><a href="#关于Security框架" class="headerlink" title="关于Security框架"></a>关于Security框架</h3><p>看了一下苹果的官方文档，Security框架是C语言写的，提供了一些管理标识码，证书，数字签名，信任等的API。<br>这里介绍一下几个常用的对象。SecIdentityRef 代码一个标识码对象，struct类型，包含一个SecKeyRef类型和一个SecCertificateRef类型。SecKeyRef就是一个非对称的key对象。SecCertificateRef是一个遵循X.509标准的证书对象。如果这两个对象没有存储到keychain中，则会把它们转换成SecKeychainItemRef对象还会使Keychain Services的函数返回错误。</p>
<p>要生成p12证书，这让我想起配置推送证书的时候，导出证书的时候便是把cer格式的证书转换成p12格式的证书。</p>
<p>iOS实现HTTPS传输<br>因为项目都是用AFN，所以就大概说下AFN的实现方法<br>如果是CA认证的证书，则直接用AFN请求便可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="line">//如果是需要验证自建证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line"></span><br><span class="line">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="line">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span><br><span class="line">//如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="line">securityPolicy.validatesDomainName = YES;</span><br></pre></td></tr></table></figure>
<p>如果是自制证书，则客户端需要导入服务端的公钥，把公钥拖进Xocde里，这里要用到把证书从pem转换成p12格式，参见上面的方法<br>2.修改验证方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (void)testClientCertificate &#123;</span><br><span class="line">  SecIdentityRef identity = NULL;</span><br><span class="line">  SecTrustRef trust = NULL;</span><br><span class="line">  NSString *p12 = [[NSBundle mainBundle] pathForResource:@&quot;testClient&quot; ofType:@&quot;p12&quot;];</span><br><span class="line">  NSData *PKCS12Data = [NSData dataWithContentsOfFile:p12];</span><br><span class="line">  </span><br><span class="line">  [[self class] extractIdentity:&amp;identity andTrust:&amp;trust fromPKCS12Data:PKCS12Data];</span><br><span class="line">  </span><br><span class="line">  NSString *url = @&quot;https://218.244.131.231/ManicureShop/api/order/pay/%@&quot;;</span><br><span class="line">  NSDictionary *dic = @&#123;@&quot;request&quot; : @&#123;</span><br><span class="line">                            @&quot;orderNo&quot; : @&quot;1409282102222110030643&quot;,</span><br><span class="line">                            @&quot;type&quot; : @(2)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">  </span><br><span class="line">  _signString = nil;</span><br><span class="line">  NSData *postData = [NSJSONSerialization dataWithJSONObject:dic</span><br><span class="line">                                                     options:NSJSONWritingPrettyPrinted</span><br><span class="line">                                                       error:nil];</span><br><span class="line">  NSString *sign = [self signWithSignKey:@&quot;test&quot; params:dic];</span><br><span class="line">  NSMutableData *body = [postData mutableCopy];</span><br><span class="line">  NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:body encoding:NSUTF8StringEncoding]);</span><br><span class="line">  url = [NSString stringWithFormat:url, sign];</span><br><span class="line">  </span><br><span class="line">  AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">  manager.requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line">  manager.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">  [manager.requestSerializer setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];</span><br><span class="line">  [manager.requestSerializer setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">  manager.responseSerializer.acceptableContentTypes = [NSSet setWithArray:@[@&quot;application/json&quot;,</span><br><span class="line">                                                                            @&quot;text/plain&quot;]];</span><br><span class="line">  manager.securityPolicy = [self customSecurityPolicy];</span><br><span class="line">  </span><br><span class="line">  [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">    NSLog(@&quot;JSON: %@&quot;, responseObject);</span><br><span class="line">  &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下面这段代码是处理SSL安全性问题的:</span><br><span class="line">/**** SSL Pinning ****/</span><br><span class="line">- (AFSecurityPolicy*)customSecurityPolicy &#123;</span><br><span class="line">  NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;testClient&quot; ofType:@&quot;cer&quot;];</span><br><span class="line">  NSData *certData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">  AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">  [securityPolicy setAllowInvalidCertificates:YES];</span><br><span class="line">  [securityPolicy setPinnedCertificates:@[certData]];</span><br><span class="line">  [securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">  /**** SSL Pinning ****/</span><br><span class="line">  return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码来自参考资料3，写的很好，没必要再说一次了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现在网络越来越发达的情况下，安全性越来越重要。不多说，https是趋势。</p>
<p>参考资料：<br><a href="https://www.jianshu.com/p/75d96b72bfb1" target="_blank" rel="noopener">1.聊聊 iOS 中的网络加密 / 滕先洪</a></p>
<p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">2.iOS安全系列之一：HTTPS / Jaminzzhang</a></p>
<p><a href="http://www.henishuo.com/ios-https-tls-ssl/" target="_blank" rel="noopener">3.iOS访问HTTPS SSL和TLS双向加密 / 标哥的技术博客</a></p>
<p><a href="https://developer.apple.com/library/mac/documentation/Security/Reference/certifkeytrustservices/" target="_blank" rel="noopener">4.苹果相关官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/04/15/a_project_report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/04/15/a_project_report/" itemprop="url">一个项目总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-15T22:25:56+08:00">
                2016-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/总结报告/" itemprop="url" rel="index">
                    <span itemprop="name">总结报告</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h3><p>项目做了一个多月了，现在进度大概五成左右<br>估计5月中旬会上线<br>当初一开始做这个项目的时候，觉得没什么的，很多东西都学过了，只需要花时间做出来就行了😌，不会的也可以边学边做<br>到后面越做越吃力，从来没有做过这么大的项目，需要注意的细节太多太多，这大概就是大项目吧</p>
<h3 id="纯代码还是IB"><a href="#纯代码还是IB" class="headerlink" title="纯代码还是IB"></a>纯代码还是IB</h3><p>这个问题刚开始的时候有点纠结，IB的缺点是多人合作的时候是很麻烦的，使用git的话只要双方拖动一下控件就很容易产生冲突，不过刚开始这个项目的时候只有我一个人，不用担心这个问题。我的第一个项目，一个需求较低的贷款类APP，界面很少但是比较繁琐，很多输入框和按钮，当初一看到界面毫不犹豫的选择了IB，做起来真的挺爽的（除了当初碰到的一些关于UIScrollView的问题）。</p>
<p>第二个项目并不是一开始做的，负责后期的一些界面和改动，当初整个项目已经写好了，但是版本有点旧，用的纯代码的frame布局，后来我写的界面用的也是frame布局，界面也不是特别复杂，做起来也还好。</p>
<p>这个项目是我的第三个项目，后来我还是选择了纯代码（其实我更倾向IB），用的是Masonry，后来用熟练了大部分界面布局起来也挺舒服。现在项目基本纯代码，Masonry布局。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>刚开始没有多想，熟悉的是MVC，一直用的也是MVC，所以就决定是MVC了。还是那个问题，后期MVC中Controller越写越大，很多逻辑都放在里面。后来师弟加进来提议用MVVM+RAC，其实我是挺喜欢尝试新东西的，我当时还没接触过RAC，然后就说好。开始用吧。</p>
<p>现在也还在熟悉RAC和MVVM，RAC用起来确实很爽，让代码模块更清晰，可读性更高。以后不出意外的话，就用MVVM和去尝试新的设计模式。</p>
<h3 id="多人合作"><a href="#多人合作" class="headerlink" title="多人合作"></a>多人合作</h3><p>因为项目很大，一个人真的很吃力，后来加进来了一个师弟，所以要开始多人合作了。当初是用Git，代码托管考虑了一些，github私密项目要收钱😝，所以就选择了开源中国的代码托管，刚开始我们都是用命令行，后来越用越蛋疼，我总是在想🤔，有没有这样的工具呢（当然有👏），查了一下，git的GUI客户端还挺多了，最后选择了大家都推荐的SourceTree，这个东西总体来说用起来很爽，比命令行爽多了，除了有两次操作失误把我两个类删了，害我要重写。</p>
<h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><p>和后台交互总是麻烦的，要写接口文档，要做各种测试，我总是在想🤔，有没有这样的工具呢（当然有👏），然后上网查了一下，发现这个还不错，SosoApi，在线API文档，但是经过后来的使用，有人有些嫌弃，最后还是放弃了使用这个，直接用pages写😝</p>
<h3 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h3><p>这个问题也是有点纠结，人家总是在说不要重复造轮子，但事实上我们连很多轮子都造不出，所以还是乖乖的用别人的吧</p>
<p>目前有用到的一些框架</p>
<ul>
<li><p>Masonry<br>布局框架，大家都在用，用了都说好</p>
</li>
<li><p>AFNetworking<br>基本都在用的网络框架</p>
</li>
<li><p>ReactiveCocoa<br>这个框架学习成本有点高，但是学会了能提高很多效率，搭配MVVM一起食用更佳😋</p>
</li>
<li><p>AFNetworking-RACExtensions<br>让RAC和AFN更爽</p>
</li>
<li><p>FMDB<br>数据库</p>
</li>
<li><p>SVProgressHUD<br>进度，状态显示，当初想自己造一个轮子，结果造的没别人好(至少学到东西了)，所以只能用别人的了</p>
</li>
<li><p>YYWebImage/YYModel<br>现在很多项目都在用SDWebImage，由于我是YY脑残粉，所以我还是选择了YYWebImage，当初看了SDWebImage的源码，嗯写的非常好，看了一下YYWebImage的源码，卧槽好强</p>
</li>
</ul>
<p>这些基本是项目必备的，还有一些例如很多界面不想写键盘事件导入的IQKeyboardManager（其实效果一般，达不到手写的效果)，还有一些强大控件类的</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>做一个项目真的需要用到很多知识，需要把学到的都用上，还是需要很好的基础才行。有些没碰到过的就要去研究，甚至有些东西听都没听过，经验就是这样积累的。也越来越觉得基础的重要性，还要努力学习。</p>
<p>附一张办公桌<br><img src="http://7xsnb0.com2.z0.glb.clouddn.com/o_IMG_3225.JPG" alt="myDesk"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/04/10/chained_coding_pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/04/10/chained_coding_pattern/" itemprop="url">链式编程思想</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T00:17:31+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="链式编程是什么"><a href="#链式编程是什么" class="headerlink" title="链式编程是什么"></a>链式编程是什么</h3><p>链式编程就是将调用多个方法用点语法连接起来，让代码更加简洁和可读性更高<br>刚开始接触链式编程是Masonry，用起来真的非常爽</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make.left.right.top.equalTo(self.view);</span><br></pre></td></tr></table></figure>
<p>这样一句语句就调用了4个方法</p>
<ul>
<li>.left调用了left属性的get方法</li>
<li>.right, .top调用了right和top方法</li>
<li>.equalTo()调用了equalTo方法</li>
</ul>
<p>这种写法极大简化了写约束的方式</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理就是调用的属性的类型或者方法的返回类型为原调用属性的类型<br>例如说UILabel调用了某个方法或者属性，得到的类型还是UILabel，那么还可以继续调用UILabel的属性或者方法</p>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>看了Masonry，我发现有两种实现方式</p>
<h4 id="1-用点语法调用方法"><a href="#1-用点语法调用方法" class="headerlink" title="1.用点语法调用方法"></a>1.用点语法调用方法</h4><p>这个其实我之前没发现，写习惯了用方括号调用方法<br>例如创建一个label 可以这样写UILabel <em>label = [[UILabel alloc] init<br>其实也可以这样写UILabel </em>label = UILabel.alloc.init<br>不过后种方法几乎没人用，苹果应该也不推荐这种写法，因为有时候这样写是没有代码提示的<br>但是有一个缺点就是不能调用有参数的方法，所以我们只能写没有参数的方法</p>
<p>创建一个UIButton的分类<br>写两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIButton *)setTextHello;</span><br><span class="line">- (UIButton *)setTextColorRed;</span><br></pre></td></tr></table></figure>
<p>并且实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UIButton *)setTextColorRed</span><br><span class="line">&#123;</span><br><span class="line">    [self setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)setImage</span><br><span class="line">&#123;</span><br><span class="line">    [self setImage:[UIImage imageNamed:@&quot;Stan1&quot;] forState:UIControlStateNormal];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个按钮的时候就可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个按钮</span><br><span class="line">UIButton *button = [UIButton buttonWithType:UIButtonTypeInfoLight];</span><br><span class="line">button.frame = CGRectMake(100, 100, 100, 100);</span><br><span class="line">button.setTextHello.setTextColorRed;</span><br><span class="line">[self.view addSubview:button];</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/chian-1.png" alt="chian-1"></p>
<p>但是会报一个警告，因为调用的是属性，但是这个属性没有被用到<br>解决方法是在调用属性前面加(void),这样就可以了</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/chian-2.png" alt="chian-2"></p>
<h4 id="2-用属性调用"><a href="#2-用属性调用" class="headerlink" title="2.用属性调用"></a>2.用属性调用</h4><p>新创建一个UILabel的分类<br>如果要传入参数的话，就返回一个UILabel的block，可以在block里面实现你想要实现的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,copy) UILabel* (^kText)(NSString *text);</span><br><span class="line">@property(nonatomic,copy) UILabel* (^kFont)(NSUInteger fontSize);</span><br><span class="line">@property(nonatomic,copy) UILabel* (^kTextColor)(UIColor *color);</span><br></pre></td></tr></table></figure>
<p>加k是为了易于区分，可以不加的<br>因为这是在分类里面的属性，不会生成setter和getter方法，所以都要自己写<br>实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (UILabel *(^)(NSUInteger))kFont</span><br><span class="line">&#123;</span><br><span class="line">    return ^(NSUInteger font)&#123;</span><br><span class="line">        [self setFont:[UIFont systemFontOfSize:font]];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *(^)(NSString *))kText</span><br><span class="line">&#123;</span><br><span class="line">    return ^(NSString *text)&#123;</span><br><span class="line">        [self setText:text];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *(^)(UIColor *))kTextColor</span><br><span class="line">&#123;</span><br><span class="line">    return ^(UIColor *color)&#123;</span><br><span class="line">        [self setTextColor:color];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setKFont:(UILabel *(^)(NSUInteger))kFont&#123;&#125;</span><br><span class="line">- (void)setKText:(UILabel *(^)(NSString *))kText&#123;&#125;</span><br><span class="line">- (void)setKTextColor:(UILabel *(^)(UIColor *))kTextColor&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不会用到setter方法，也不能用，所以setter方法设为空<br>然后就能愉快的链式编程了</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/chian-3.png" alt="chian-3"></p>
<p>然后我再想，假如没有参数呢，刚开始是想block没有参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,copy) UILabel* (^aText)();</span><br><span class="line">@property(nonatomic,copy) UILabel* (^aFont)();</span><br><span class="line">@property(nonatomic,copy) UILabel* (^aTextColor)();</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (UILabel *(^)())aFont</span><br><span class="line">&#123;</span><br><span class="line">    return ^()&#123;</span><br><span class="line">        [self setFont:[UIFont systemFontOfSize:16.0f]];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *(^)())aTextColor</span><br><span class="line">&#123;</span><br><span class="line">    return ^()&#123;</span><br><span class="line">        [self setTextColor:[UIColor cyanColor]];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *(^)())aText</span><br><span class="line">&#123;</span><br><span class="line">    return ^()&#123;</span><br><span class="line">        [self setText:@&quot;这还是一个label&quot;];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setAFont:(UILabel *(^)())aFont&#123;&#125;</span><br><span class="line">- (void)setAText:(UILabel *(^)())aText&#123;&#125;</span><br><span class="line">- (void)setATextColor:(UILabel *(^)())aTextColor&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>后来发现调用的时候还是要这样<br><img src="http://7xsnb0.com2.z0.glb.clouddn.com/chian-4.png" alt="chian-4"></p>
<p>尝试了一下，最后一个调用能去掉括号，报警告，能运行，但是没效果</p>
<p>所以我想为什么不直接调用属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) UILabel *bText;</span><br><span class="line">@property(nonatomic,strong) UILabel *bFont;</span><br><span class="line">@property(nonatomic,strong) UILabel *bTextColor;</span><br></pre></td></tr></table></figure>
<p>getter &amp;&amp; setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (UILabel *)bText</span><br><span class="line">&#123;</span><br><span class="line">    [self setText:@&quot;labellabel&quot;];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *)bTextColor</span><br><span class="line">&#123;</span><br><span class="line">    [self setTextColor:[UIColor purpleColor]];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *)bFont</span><br><span class="line">&#123;</span><br><span class="line">    [self setFont:[UIFont systemFontOfSize:13.0f]];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setBFont:(UILabel *)bFont&#123;&#125;</span><br><span class="line">- (void)setBText:(UILabel *)bText&#123;&#125;</span><br><span class="line">- (void)setBTextColor:(UILabel *)bTextColor&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label3 = [[UILabel alloc] initWithFrame:CGRectMake(100, 400, 200, 100)];</span><br><span class="line">(void)label3.bTextColor.bText.bFont;</span><br><span class="line">[self.view addSubview:label3];</span><br></pre></td></tr></table></figure>
<p>如果调用不加(void)还是会报警告<br>如果想像Masonry那样的链式编程可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label3 = [[UILabel alloc] initWithFrame:CGRectMake(100, 400, 200, 100)];</span><br><span class="line">label3.bTextColor.bText.kFont(30);</span><br><span class="line">[self.view addSubview:label3];</span><br></pre></td></tr></table></figure>
<p>这样就不会报警告,整洁清晰</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/03/10/sdwebimage_reading_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/03/10/sdwebimage_reading_note/" itemprop="url">读SDWebImage笔记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-10T22:07:06+08:00">
                2016-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>github地址：</p>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">https://github.com/rs/SDWebImage</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个异步图片下载及缓存的库</p>
<p>特性：</p>
<ul>
<li>一个扩展UIImageView分类的库，支持加载网络图片并缓存图片</li>
<li>异步图片下载器</li>
<li>异步图片缓存和自动图片有效期管理</li>
<li>支持GIF动态图片</li>
<li>支持WebP</li>
<li>背景图片减压</li>
<li>保证同一个URL不会再次下载</li>
<li>保证无效的URL不会重新加载</li>
<li>保证主线程不会死锁</li>
<li>性能优越</li>
<li>使用GCD和ARC</li>
<li>支持ARM64位处理器</li>
<li>用法不说了 github上有，挺简单的</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>只要有图片的url，就能下载到图片，使用SDWebImage的好处就是缓存机制，每次取图片先判断是否在内存中，再到缓存中查找，找到了直接加载，在缓存中找不到才重新下载，url也会记录，是否是失效的url，是则不会再尝试。下载到的图片会缓存，用于下次可以直接加载。图片下载，解码，转换都异步进行，不会阻塞主线程。</p>
<h3 id="类的作用"><a href="#类的作用" class="headerlink" title="类的作用"></a>类的作用</h3><ul>
<li><p>SDImageCache<br>设置缓存的类型，方式，路径等</p>
</li>
<li><p>SDWebImageCompat<br>兼容类，定义了很多宏和一个转换图片的方法</p>
</li>
<li><p>SDWebImageDecoder<br>解码器，让图片色彩转换（涉及到color space）</p>
</li>
<li><p>SDWebImageDownloader<br>下载器，设置下载相关，要用到SDWebImageDownloaderOperation</p>
</li>
<li><p>SDWebImageDownloaderOperation<br>下载器的操作</p>
</li>
<li><p>SDWebImageManager<br>管理图片下载，取消操作，判断url是否已缓存等</p>
</li>
<li><p>SDWebImageOperation<br>图片操作，后面很多类都要用到</p>
</li>
<li><p>SDWebImagePrefetcher<br>预抓取器，预先下载urls中的图片</p>
</li>
<li><p>UIButton+WebCache<br>按钮图片的缓存</p>
</li>
<li><p>UIImage+GIF<br>缓存gif</p>
</li>
<li><p>NSData+ImageContentType<br>判断图片的类型,png/jpeg/gif/webp</p>
</li>
<li><p>UIImage+MultiFormat<br>缓存多种格式的图片，要用到NSData+ImageContentType的判断图片类型方法和UIImage+GIF的判断是否为gif图片方法，以及ImageIO里面的方法</p>
</li>
<li><p>UIImageView+HighlightedWebCache<br>缓存高亮图片</p>
</li>
<li><p>UIImageView+WebCache<br>主要用到这个，加载及缓存UIImageView的图片</p>
</li>
<li><p>UIView+WebCacheOperation<br>缓存的操作，有缓存，取消操作，移除缓存</p>
</li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>先讲一些比较边缘的方法</p>
<h4 id="0-SDWebImageOperation"><a href="#0-SDWebImageOperation" class="headerlink" title="0.SDWebImageOperation"></a>0.SDWebImageOperation</h4><p>图片操作，只有头文件，定义了协议SDWebImageOperation，里面也只有取消方法<br>这个类后面很多类都要用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="1-NSData-ImageContentType"><a href="#1-NSData-ImageContentType" class="headerlink" title="1.NSData+ImageContentType"></a>1.NSData+ImageContentType</h4><p>这个文件是NSData的分类，只有一个方法，传入图片数据，根据图片的头标识来确定图片的类型。头标识都不一样，只需获取文件头字节，对比十六进制信息，判断即可。</p>
<p>图片文件    头标识    十六进制头字节<br>jpeg/jpg    FFD8    0xFF<br>png    8950    0x89<br>gif    4749    0x47<br>tiff    4D4D / 4949    0x49/0x4D<br>Webp格式开头是0x52，但是还有可能是其他类型文件，所以要识别前缀为<br>52 49 46 46 对应 RIFF<br>后缀 57 45 42 50 对应 WEBP，符合这些条件的才是webp图片文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)sd_contentTypeForImageData:(NSData *)data &#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return @&quot;image/jpeg&quot;;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return @&quot;image/png&quot;;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return @&quot;image/gif&quot;;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return @&quot;image/tiff&quot;;</span><br><span class="line">        case 0x52:</span><br><span class="line">            // R as RIFF for WEBP</span><br><span class="line">            if ([data length] &lt; 12) &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                return @&quot;image/webp&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-SDWebImageCompat"><a href="#2-SDWebImageCompat" class="headerlink" title="2.SDWebImageCompat"></a>2.SDWebImageCompat</h4><p>兼容类，这个类定义了很多宏还有一个伸缩图片的方法，宏就不说了<br>这个方法定义成C语言式的内联方法<br>核心代码如下，传入key和图片，如果key中出现@2x就设定scale为2.0,出现@3x就设定scale为3.0，然后伸缩图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CGFloat scale = [UIScreen mainScreen].scale;</span><br><span class="line">if (key.length &gt;= 8) &#123;</span><br><span class="line">    NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">    if (range.location != NSNotFound) &#123;</span><br><span class="line">        scale = 2.0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">    if (range.location != NSNotFound) &#123;</span><br><span class="line">        scale = 3.0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">image = scaledImage;</span><br></pre></td></tr></table></figure>
<h4 id="3-SDWebImageDecoder"><a href="#3-SDWebImageDecoder" class="headerlink" title="3.SDWebImageDecoder"></a>3.SDWebImageDecoder</h4><p>这个是解码器类，只定义了一个解码方法，传入图片，返回的也是图片<br>CGImageRef是一个指针类型。typedef struct CGImage *CGImageRef;<br>获取传入图片的alpha信息，然后判断是否符合苹果定义的CGImageAlphaInfo，如果是就返回原图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CGImageRef imageRef = image.CGImage;</span><br><span class="line"> </span><br><span class="line">CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef);</span><br><span class="line">BOOL anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                 alpha == kCGImageAlphaLast ||</span><br><span class="line">                 alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                 alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line"> </span><br><span class="line">if (anyAlpha) &#123; </span><br><span class="line">    return image; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后获取图片的宽高和color space（指定颜色值如何解释），判断color space是否支持，不支持就转换为支持的模式（RGB)，再用图形上下文根据获得的信息画出来，释放掉创建的CG指针再返回图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">size_t height = CGImageGetHeight(imageRef);</span><br><span class="line"> </span><br><span class="line">// current</span><br><span class="line">CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));</span><br><span class="line">CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);</span><br><span class="line"> </span><br><span class="line">bool unsupportedColorSpace = (imageColorSpaceModel == 0 || imageColorSpaceModel == -1 || imageColorSpaceModel == kCGColorSpaceModelCMYK || imageColorSpaceModel == kCGColorSpaceModelIndexed);</span><br><span class="line">if (unsupportedColorSpace)</span><br><span class="line">    colorspaceRef = CGColorSpaceCreateDeviceRGB();</span><br><span class="line"> </span><br><span class="line">CGContextRef context = CGBitmapContextCreate(NULL, width,</span><br><span class="line">                                             height,</span><br><span class="line">                                             CGImageGetBitsPerComponent(imageRef),</span><br><span class="line">                                             0,</span><br><span class="line">                                             colorspaceRef,</span><br><span class="line">                                             kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">CGImageRef imageRefWithAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">UIImage *imageWithAlpha = [UIImage imageWithCGImage:imageRefWithAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">if (unsupportedColorSpace)</span><br><span class="line">    CGColorSpaceRelease(colorspaceRef);</span><br><span class="line">CGContextRelease(context);</span><br><span class="line">CGImageRelease(imageRefWithAlpha);</span><br><span class="line"> </span><br><span class="line">return imageWithAlpha;</span><br></pre></td></tr></table></figure>
<p>这个算是核心部分</p>
<h4 id="4-UIView-WebCacheOperation"><a href="#4-UIView-WebCacheOperation" class="headerlink" title="4.UIView+WebCacheOperation"></a>4.UIView+WebCacheOperation</h4><p>缓存操作的UIView的分类，支持三种操作，也是整个库中比较核心的操作。<br>但是首先我们来了解三种操作都要用到的存储数据的方法。<br>这两个方法用的是OC中runtime方法，原理是两个文件关联方法，和上层的存储方法差不多，传入value和key对应，取出也是根据key取出value<br>object传入self即可</p>
<p>1.设置关联方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//传入object和key和value，policy</span><br><span class="line">//policy即存储方式，和声明使用几种属性大致相同，有copy,retain,copy,retain_nonatomic,assign 五种）</span><br><span class="line"> </span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>
<p>2.取出方法</p>
<p>//传入object和key返回value<br>id objc_getAssociatedObject(id object, const void *key)<br>这个方法是三种操作都要用到的，获得数据<br>这个方法是使用前面两个方法，根据缓存加载数据<br>有缓存则从缓存中取出数据，没有则缓存数据，返回格式是字典格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    operations = [NSMutableDictionary dictionary];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是三种操作</p>
<p>一.加载图片根据是否有缓存<br>从获得数据方法获得数据，传入key，先调用第二个方法停止操作，再根据key缓存数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二.取消加载图片如果有缓存<br>先获得方法一的返回字典数据，传入key在返回的字典中查找是否已经存在，如果存在则取消所有操作<br>conformsToProtocol方法如果符合这个协议（协议中声明了取消方法），调用协议中的取消方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    // Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    id operations = [operationDictionary objectForKey:key];</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三.移除缓存<br>获得方法一的数据，传入key如果key对应的数据在数据中则移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_removeImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary removeObjectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-SDWebImageDownloader"><a href="#5-SDWebImageDownloader" class="headerlink" title="5.SDWebImageDownloader"></a>5.SDWebImageDownloader</h4><p>下载器类，需要用到SDWebImageDownloaderOperation类，下载器操作，后面会说到</p>
<p>定义了一些属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//下载队列的最大下载数</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line">//当前下载数</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line">//下载超时的时间</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line">//是否解压图片，默认是</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line">//下载器顺序，枚举类型，有两种，先进先出，还是后进先出</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line"> </span><br><span class="line">#####还有一些用户属性</span><br><span class="line">//url证书</span><br><span class="line"> </span><br><span class="line">@property (strong, nonatomic) NSURLCredential *urlCredential;</span><br><span class="line">//用户名</span><br><span class="line">@property (strong, nonatomic) NSString *username;</span><br><span class="line">//密码</span><br><span class="line">@property (strong, nonatomic) NSString *password;</span><br><span class="line">//头像过滤器，block指针类型，接受url和字典headers</span><br><span class="line">@property (nonatomic, copy) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br></pre></td></tr></table></figure>
<p>init方法<br>初始化了一些属性和写好http请求头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _URLCallbacks = [NSMutableDictionary new];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心方法<br>传入url，下载器选项（接下来会说），进度block，完成回调block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>这个方法非常复杂，定义了http请求，定义了SDWebImageDownloaderOperation实例，即下载器操作，初始化过程非常复杂，用到了http请求，用到了前面定义的那些属性，最后返回这个操作，这个过程建议去看源码</p>
<h4 id="6-SDWebImageDownloaderOperation"><a href="#6-SDWebImageDownloaderOperation" class="headerlink" title="6.SDWebImageDownloaderOperation"></a>6.SDWebImageDownloaderOperation</h4><p>下载器的操作<br>直接看前面下载器需要用到的初始化方法<br>需要初始化了各种属性，主要是几个block，进度block，完成回调block，取消回调block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithRequest:(NSURLRequest *)request</span><br><span class="line">              options:(SDWebImageDownloaderOptions)options</span><br><span class="line">             progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">            completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">            cancelled:(SDWebImageNoParamsBlock)cancelBlock &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _request = request;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldUseCredentialStorage = YES;</span><br><span class="line">        _options = options;</span><br><span class="line">        _progressBlock = [progressBlock copy];</span><br><span class="line">        _completedBlock = [completedBlock copy];</span><br><span class="line">        _cancelBlock = [cancelBlock copy];</span><br><span class="line">        _executing = NO;</span><br><span class="line">        _finished = NO;</span><br><span class="line">        _expectedSize = 0;</span><br><span class="line">        responseFromCached = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-SDWebImageManager"><a href="#7-SDWebImageManager" class="headerlink" title="7.SDWebImageManager"></a>7.SDWebImageManager</h4><p>图片管理器，负责图片的下载，转换，缓存等<br>这里先说明SDWebImageOptions<br>1 &lt;&lt; X 这种是位运算符，1左移多少位，后面要用到，说明一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">SDWebImageRetryFailed = 1 &lt;&lt; 0，//无效url会加入黑名单，这个标志是禁用黑名单</span><br><span class="line">SDWebImageLowPriority = 1 &lt;&lt; 1, //低优先级，会后下载</span><br><span class="line">SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //禁用磁盘缓存</span><br><span class="line">SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //显示下载进度，下载完才显示</span><br><span class="line">SDWebImageRefreshCached = 1 &lt;&lt; 4, //重新从远程缓存</span><br><span class="line">SDWebImageContinueInBackground = 1 &lt;&lt; 5, //在后台继续下载图片</span><br><span class="line">SDWebImageHandleCookies = 1 &lt;&lt; 6, //把cookie存储到NSHTTPCookieStorey</span><br><span class="line">SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //允许非信任ssl证书</span><br><span class="line">SDWebImageHighPriority = 1 &lt;&lt; 8, //高优先级，插队下载队列</span><br><span class="line">SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //显示的是替代图片(初始化图片)</span><br><span class="line">SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, //转换图片大小</span><br><span class="line">SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11 //避免自动设置图片（想手动的时候设置)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里包含了各种选择</p>
<p>核心方法<br>传入url，上面的options，进度block，完成回调block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>实例化过程请去看源码</p>
<p>说下其他方法<br>一个传入key判断图片是否存在存储空间的方法<br>使用的是NSFileManager的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)diskImageExistsWithKey:(NSString *)key &#123;</span><br><span class="line">    BOOL exists = NO;</span><br><span class="line">    exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line"> </span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        exists = [[NSFileManager defaultManager] fileExistsAtPath:[[self defaultCachePathForKey:key] stringByDeletingPathExtension]];</span><br><span class="line">    &#125;</span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有从存储空间或者缓存取出图片的方法<br>self.memCache是AutoPurgeCache（单纯继承自NSCache）的实例<br>从存储空间取图片要先判断内存中是否存在，然后才从存储空间中查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</span><br><span class="line"> </span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image = [UIImage sd_imageWithData:data];</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.shouldDecompressImages) &#123;</span><br><span class="line">            image = [UIImage decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有几个清除方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearDisk;</span><br><span class="line">- (void)clearMemory;</span><br><span class="line"> </span><br><span class="line">- (void)cleanDisk;</span><br><span class="line">- (void)cleanDiskWithCompletionBlock;</span><br></pre></td></tr></table></figure>
<h4 id="8-SDWebImagePrefetcher"><a href="#8-SDWebImagePrefetcher" class="headerlink" title="8.SDWebImagePrefetcher"></a>8.SDWebImagePrefetcher</h4><p>预抓取器，用来预抓取图片<br>核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//预抓取图片</span><br><span class="line">- (void)prefetchURLs:(NSArray *)urls progress:(SDWebImagePrefetcherProgressBlock)progressBlock completed:(SDWebImagePrefetcherCompletionBlock)completionBlock;</span><br><span class="line">//取消预抓取图片</span><br><span class="line">- (void)cancelPrefetching;</span><br></pre></td></tr></table></figure>
<p>先来看预抓取图片<br>传入url，进度block，完成回调block<br>首先取消抓取，然后重新开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)prefetchURLs:(NSArray *)urls progress:(SDWebImagePrefetcherProgressBlock)progressBlock completed:(SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    [self cancelPrefetching]; // Prevent duplicate prefetch request</span><br><span class="line">    self.startedTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    self.prefetchURLs = urls;</span><br><span class="line">    self.completionBlock = completionBlock;</span><br><span class="line">    self.progressBlock = progressBlock;</span><br><span class="line"> </span><br><span class="line">    if (urls.count == 0) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(0,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSUInteger listCount = self.prefetchURLs.count;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; self.maxConcurrentDownloads &amp;&amp; self.requestedCount &lt; listCount; i++) &#123;</span><br><span class="line">            [self startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用startPrefetchingAtIndex:方法，再调用self.manager的核心方法，即开始下载图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>最后是各种分类，即直接再初始化的控件设置图片，支持UIButton，UIImage,UIImageView，大同小异，我直接说UIImageView+WebCache</p>
<h4 id="9-UIImageView-WebCache"><a href="#9-UIImageView-WebCache" class="headerlink" title="9.UIImageView+WebCache"></a>9.UIImageView+WebCache</h4><p>很多加载方法最终都会以缺省参数方式或者直接调用这个方法，传入一个URL，一个用来初始化的image，一个options（枚举，下面详细说明），一个progressBlock（返回图片接受进度等），一个completedBlock（完成回调block）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>首先根据url缓存图片，这里用到的是OC的runtime中的关联方法（见4）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure>
<p>然后判断options（见7）是其他选择则直接给图片赋值placehoder图片，这里判断使用的是 &amp; 与 位运算符，SDWebImageDelayPlacehoder是 1 &lt;&lt; 9，1左移9位与options相与</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        <span class="keyword">self</span>.image = placeholder;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果url存在，则定义图片操作，使用图片管理器的单例来调用核心方法（下载图片方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">    //过程省略</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-UIImage-GIF"><a href="#10-UIImage-GIF" class="headerlink" title="10.UIImage+GIF"></a>10.UIImage+GIF</h4><p>gif的实现使用了ImageIO中的CGImageSourceRef<br>用获得的gif数据得到CGImageSourceRef，然后算出时间，在这个时间内把图片一帧一帧的放进一个数组，最后再把这个数组和时间转成图片，就成了gif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line"> </span><br><span class="line">    size_t count = CGImageSourceGetCount(source);</span><br><span class="line"> </span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line"> </span><br><span class="line">    if (count &lt;= 1) &#123;</span><br><span class="line">        animatedImage = [[UIImage alloc] initWithData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSMutableArray *images = [NSMutableArray array];</span><br><span class="line"> </span><br><span class="line">        NSTimeInterval duration = 0.0f;</span><br><span class="line"> </span><br><span class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line"> </span><br><span class="line">            duration += [self sd_frameDurationAtIndex:i source:source];</span><br><span class="line"> </span><br><span class="line">            [images addObject:[UIImage imageWithCGImage:image scale:[UIScreen mainScreen].scale orientation:UIImageOrientationUp]];</span><br><span class="line"> </span><br><span class="line">            CGImageRelease(image);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (!duration) &#123;</span><br><span class="line">            duration = (1.0f / 10.0f) * count;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        animatedImage = [UIImage animatedImageWithImages:images duration:duration];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CFRelease(source);</span><br><span class="line"> </span><br><span class="line">    return animatedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完SDWebImage的源码后感觉学到了很多东西，特别是缓存那一块写的特别好。ImageIO和objc/runtime很值得学习一下。也感觉到设计出这样一个库需要很强大的知识面，非常严谨的思想，真的不容易。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/03/10/xmpp_simple_im/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/03/10/xmpp_simple_im/" itemprop="url">xmpp_simple_im</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-10T20:01:05+08:00">
                2016-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="搭建服务器和数据库"><a href="#搭建服务器和数据库" class="headerlink" title="搭建服务器和数据库"></a>搭建服务器和数据库</h3><p>搭载服务器我用的是openfire，数据库用的是mysql</p>
<p>这里推荐两篇文章</p>
<p>配置mysql，用的是<code>mysql workbench</code></p>
<p><a href="http://justsee.iteye.com/blog/1753467" target="_blank" rel="noopener">http://justsee.iteye.com/blog/1753467</a></p>
<p>配置服务器 <code>Openfire</code></p>
<p><a href="http://www.cnblogs.com/xiaodao/archive/2013/04/05/3000554.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaodao/archive/2013/04/05/3000554.html</a></p>
<p>先配置好数据库然后配置服务器<br>然后两个都打开</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-1.png" alt="xmpp-1"></p>
<p>数据库也打开</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-2.png" alt="xmpp-2"></p>
<p>下一个XMPP客户端，就是用来测试的<br>我下的是Adium</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-3.png" alt="Adium"></p>
<p><a href="https://xmpp.org/software/clients.html" target="_blank" rel="noopener">这里下</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>然后在Adium里面添加帐号，服务器要用openfire设置好的127.0.0.1，端口用5222</p>
<p>这里openfire里面的服务器端口，5222是客户端连接服务器</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-4.png" alt="server"></p>
<p>登录成功后可以在openfire里面看到用户已经在线</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-5.png" alt="online"></p>
<p>然后另一客户端，我直接用代码，觉得麻烦没做界面</p>
<p>简单实现<br>设置XMPPStream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (XMPPStream *)stream</span><br><span class="line">&#123;</span><br><span class="line">    if (!_stream) &#123;</span><br><span class="line">        _stream = [[XMPPStream alloc] init];</span><br><span class="line">        [_stream addDelegate:self delegateQueue:dispatch_get_current_queue()];</span><br><span class="line">    &#125;</span><br><span class="line">    return _stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后设置帐号，只是测试，所以直接在viewDidLoad里面写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self.stream setMyJID:[XMPPJID jidWithString:@&quot;test123@127.0.0.1&quot;]];</span><br><span class="line">    [self.stream setHostName:@&quot;127.0.0.1&quot;];</span><br><span class="line">    [self.stream setHostPort:5222];</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [self.stream connectWithTimeout:1.0f error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;connectWithTimeout : %@&quot;,error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是验证密码，下面的方法是上线，这些是代理方法，记得设置XMPPStream的代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)xmppStreamDidConnect:(XMPPStream *)sender</span><br><span class="line">&#123;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [self.stream authenticateWithPassword:@&quot;test123&quot; error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;authenticateWithPassword : %@&quot;,error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender</span><br><span class="line">&#123;</span><br><span class="line">    XMPPPresence *presence = [XMPPPresence presence];</span><br><span class="line">    [self.stream sendElement:presence];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是接受信息的方法，我没做界面，直接打印出来接受的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">    NSString *msg = [[message elementsForName:@&quot;body&quot;] lastObject];</span><br><span class="line">    NSLog(@&quot;%@&quot;,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果验证失败的话，会调用这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;didNotAuthenticate : %@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来在openfire查看用户名必须带 服务器名</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-6.png" alt="serverlist"></p>
<p>例如我的帐号是test123，设置JID的用户名就是<code>test123@127.0.0.1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.stream setMyJID:[XMPPJID jidWithString:@&quot;test123@127.0.0.1&quot;]];</span><br></pre></td></tr></table></figure>
<p>然后运行，没有报错，在openfire显示已经在线</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-7.png" alt="online2"></p>
<p>然后就可以开始聊天了，下面的是刚发的，上面的是之前的聊天记录</p>
<p>发了文字和一个链接</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-8.png" alt="chat"></p>
<p>然后Xcode输出</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/xmpp-9.png" alt=""></p>
<p>即时通讯最简单的就这样，退出APP后openfire后台就会显示下线</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2015/10/27/adhoc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2015/10/27/adhoc/" itemprop="url">Ad Hoc测试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-27T19:04:40+08:00">
                2015-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于最近某个项目需要给别人测试，使用的是Ad Hoc方法<br>首先登录开发者官网配置证书</p>
<h4 id="1-添加Certificates，从电脑获取certSigningRequest然后添加进去"><a href="#1-添加Certificates，从电脑获取certSigningRequest然后添加进去" class="headerlink" title="1.添加Certificates，从电脑获取certSigningRequest然后添加进去"></a>1.添加Certificates，从电脑获取certSigningRequest然后添加进去</h4><h4 id="2-在Identifiers里面的App-IDs添加要调试App的Bundle-ID和名字"><a href="#2-在Identifiers里面的App-IDs添加要调试App的Bundle-ID和名字" class="headerlink" title="2.在Identifiers里面的App IDs添加要调试App的Bundle ID和名字"></a>2.在Identifiers里面的App IDs添加要调试App的Bundle ID和名字</h4><h4 id="3-在Devices里面添加要给别人测试的手机的UDID"><a href="#3-在Devices里面添加要给别人测试的手机的UDID" class="headerlink" title="3.在Devices里面添加要给别人测试的手机的UDID"></a>3.在Devices里面添加要给别人测试的手机的UDID</h4><p>前几步都和真机调试一样，简单说明一下</p>
<h4 id="4-在Provisioning-Profiles-里面添加profiles的时候选择Ad-Hoc"><a href="#4-在Provisioning-Profiles-里面添加profiles的时候选择Ad-Hoc" class="headerlink" title="4.在Provisioning Profiles 里面添加profiles的时候选择Ad Hoc"></a>4.在Provisioning Profiles 里面添加profiles的时候选择Ad Hoc</h4><p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/756114-20151027100118310-497055954.png" alt="Ad_Hoc"></p>
<p>continue<br>　　选择要调试的App的App ID</p>
<p>continue<br>　　选择开发者</p>
<p>continue<br>　　选择要调试的手机（可以多选）</p>
<p>continue<br>　　输入保存的证书的名字，然后Generate，生成之后要下载下来 　　</p>
<h4 id="5-保存下来证书之后，打开Xcode，双击证书"><a href="#5-保存下来证书之后，打开Xcode，双击证书" class="headerlink" title="5.保存下来证书之后，打开Xcode，双击证书"></a>5.保存下来证书之后，打开Xcode，双击证书</h4><h4 id="6-在Xocde-Preferences-Account里面添加刚才设置证书的开发者帐号，如果已添加就跳过此步骤"><a href="#6-在Xocde-Preferences-Account里面添加刚才设置证书的开发者帐号，如果已添加就跳过此步骤" class="headerlink" title="6.在Xocde-Preferences-Account里面添加刚才设置证书的开发者帐号，如果已添加就跳过此步骤"></a>6.在Xocde-Preferences-Account里面添加刚才设置证书的开发者帐号，如果已添加就跳过此步骤</h4><h4 id="7-然后在项目PROJECT-Build-Settings-Code-Signing里面的Provisioning-Profile里面添加下载的Ad-Hoc证书"><a href="#7-然后在项目PROJECT-Build-Settings-Code-Signing里面的Provisioning-Profile里面添加下载的Ad-Hoc证书" class="headerlink" title="7.然后在项目PROJECT-Build Settings-Code Signing里面的Provisioning Profile里面添加下载的Ad Hoc证书"></a>7.然后在项目PROJECT-Build Settings-Code Signing里面的Provisioning Profile里面添加下载的Ad Hoc证书</h4><p>如果没有这个选项的话，再次双击生成的Ad Hoc证书</p>
<p>Provisioning Profile上面的开发者全部选择设置了证书的开发者帐号</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/756114-20151027101624154-609807275.png" alt="Code_Signing"></p>
<p>连接真机，看是否可以正常运行</p>
<h4 id="8-Xcode菜单栏中选择Product-Archive，即会弹出Organizer窗口（已经Archive过了可以从菜单栏Window-Organizer打开）"><a href="#8-Xcode菜单栏中选择Product-Archive，即会弹出Organizer窗口（已经Archive过了可以从菜单栏Window-Organizer打开）" class="headerlink" title="8.Xcode菜单栏中选择Product-Archive，即会弹出Organizer窗口（已经Archive过了可以从菜单栏Window-Organizer打开）"></a>8.Xcode菜单栏中选择Product-Archive，即会弹出Organizer窗口（已经Archive过了可以从菜单栏Window-Organizer打开）</h4><p>然后选择Export，选择Save For Ad Hoc Deployment，然后Next</p>
<p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/756114-20151027102331247-1201210840.png" alt="organizer"></p>
<h4 id="9-会弹出窗口让你选择开发者，选择设置过证书的开发者"><a href="#9-会弹出窗口让你选择开发者，选择设置过证书的开发者" class="headerlink" title="9.会弹出窗口让你选择开发者，选择设置过证书的开发者"></a>9.会弹出窗口让你选择开发者，选择设置过证书的开发者</h4><h4 id="10-导出"><a href="#10-导出" class="headerlink" title="10.导出"></a>10.导出</h4><p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/756114-20151027102524200-945274110.png" alt="device_support"></p>
<h4 id="11-选择Next"><a href="#11-选择Next" class="headerlink" title="11.选择Next"></a>11.选择Next</h4><p><img src="http://7xsnb0.com2.z0.glb.clouddn.com/756114-20151027102748544-523448479.png" alt="summary"></p>
<p>1框框内会显示配置好的Ad Hoc证书，如果显示*，则出现问题，请登录开发者官网查看Ad Hoc证书是否valid（如果invalid则edit一下为valid）</p>
<p>如果显示正确，就直接Next</p>
<h4 id="12-然后就生成APP的ipa了，这个程序就可以拿去给别人测试了。"><a href="#12-然后就生成APP的ipa了，这个程序就可以拿去给别人测试了。" class="headerlink" title="12.然后就生成APP的ipa了，这个程序就可以拿去给别人测试了。"></a>12.然后就生成APP的ipa了，这个程序就可以拿去给别人测试了。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2015/10/13/simply_controller_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2015/10/13/simply_controller_summary/" itemprop="url">轻量化ViewController，读文章做的总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-13T22:37:22+08:00">
                2015-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>轻量化ViewControllers顾名思义就是把ViewController的代码进行简化让控制器更简单更清晰</p>
<h3 id="把DataSource和其他protocol分离出控制器"><a href="#把DataSource和其他protocol分离出控制器" class="headerlink" title="把DataSource和其他protocol分离出控制器"></a>把DataSource和其他protocol分离出控制器</h3><p>因为做项目很多控制器都TableViewController，所以必须要有数据源(TableViewDataSource)输入，一般DataSource的3个方法都在控制器里<br>我们的目的就是要把他分离出来，方法就是自定义一个类，然后控制器调用这个类并且这个数据源类是通用的，别的TableViewController或者有定义了tableView/collectionView的控制器都可以调用自定义ArrayDataSource类</p>
<p>1.定义一个Block，用于传递cell和数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^TableViewCellPassBlock)(id cell, id item);</span><br></pre></td></tr></table></figure>
<p>2.定义一个方法给控制器调用，用于初始化ArrayDataSource类（需要暴露在.h文件中）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSArray *items;</span><br><span class="line">@property (nonatomic, copy) NSString *cellIdentifier;</span><br><span class="line">@property(nonatomic, copy) TableViewCellPassBlock passBlock;</span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"> *  初始化数据源的方法</span><br><span class="line"> *  @param anItems         用于接受数据的数组</span><br><span class="line"> *  @param aCellIdentifier 接收cell的ID</span><br><span class="line"> *  @param aPassBlock      接收传递的Block</span><br><span class="line"> */</span><br><span class="line"> - (id)initWithItems:(NSArray *)anItems cellIdentifier:(NSString *)aCellIdentifier passBlock(TableViewCellPassBlock)aPassBlock &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">	if(self)&#123;</span><br><span class="line">		self.items = anItems;</span><br><span class="line">		self.cellIdentifier = aCellIdentifier;</span><br><span class="line">		self.passBlock = [aPassBlock copy];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.然后就是数据源的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** 这个方法找出数组的数据 后面要用到*/</span><br><span class="line">- (id)itemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	return self.items[(NSUInteger) indexPath.row];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">	return self.items.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">	UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: self.cellIdentifier forIndexPath: indexPath];</span><br><span class="line">	id item = [self itemAtIndexPath: indexPath];</span><br><span class="line">	self.passBlock(cell, item);</span><br><span class="line">	return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayDataSource类就这样定义完成了<br>接下来是控制器的调用<br>只需要写以下几行代码便可以设置tableView的数据源，不用每个控制器都写那三个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//数组传数据是接下来要简化的，后面会详细说明</span><br><span class="line">NSArray *arr = [AppDelegate sharedDelegate].returnModel.returnData;</span><br><span class="line">//使用Block回调，传递cell和模型数据</span><br><span class="line">TableViewCellPassBlock passBlock = ^(TestModelCell *cell,TestModel *model)&#123;</span><br><span class="line">	//测试方法，只是传递model给cell，这个方法用分类写的，自定义cell的分类</span><br><span class="line">	[cell setName: model];</span><br><span class="line">&#125;;</span><br><span class="line">//初始化并设置tableView的数据源</span><br><span class="line">self.dataSource = [[ArrayDataSource alloc] initWithItems: arr cellIdentifier:@&quot;TestModelCell&quot; passBlock: passBlock];</span><br><span class="line">self.tableView.dataSource = self.dataSource;</span><br></pre></td></tr></table></figure>
<h3 id="二、将业务逻辑放到model中"><a href="#二、将业务逻辑放到model中" class="headerlink" title="二、将业务逻辑放到model中"></a>二、将业务逻辑放到model中</h3><p>一些跟控制器无关的代码可以放到模型中<br>测试代码我写了一个TestModel，只有一个属性和一个初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)name;</span><br></pre></td></tr></table></figure>
<p>然后又写了一个model，因为要返回数据所以我叫ReturnModel<br>在.h文件中暴露的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//类方法，创建的时候用这个方法</span><br><span class="line">+ (instancetype)returnModel;</span><br><span class="line"></span><br><span class="line">//这个方法用于返回数据</span><br><span class="line">- (NSArray *)returnData;</span><br></pre></td></tr></table></figure>
<p>然后在.m文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)returnModel</span><br><span class="line">&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">	//调用方法执行业务逻辑的方法</span><br><span class="line">	[self doSomething];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以在这个方法中执行与控制器无关的业务逻辑</span><br><span class="line">- (void)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;try to do something&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这个方法中返回模型数据，数据略</span><br><span class="line"></span><br><span class="line">- (NSArray *)returnData</span><br><span class="line">&#123;</span><br><span class="line">　　NSArray *array = [[NSArray alloc] initWithObject:...];</span><br><span class="line">　　return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是在返回数据的模型类中执行业务逻辑，在创建类的时候执行<br>在AppDelegate中添加方法和属性，并且暴露在.h文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedDelegate</span><br><span class="line">&#123;</span><br><span class="line">	return [UIApplication sharedApplication].delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@synthesize returnModel = _returnModel;</span><br><span class="line"></span><br><span class="line">- (ReturnModel *)returnModel</span><br><span class="line">&#123;</span><br><span class="line">	if (_returnModel == nil) &#123;</span><br><span class="line">		_returnModel = [ReturnModel returnModel];</span><br><span class="line">	&#125;</span><br><span class="line">	return _returnModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以控制器直接调用方法得到数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = [AppDelegate sharedDelegate].returnModel.returnData;</span><br></pre></td></tr></table></figure>
<p>这时候控制器已经很简化了<br>可以把网络请求也放在model层</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://objccn.io/issue-1-1/" target="_blank" rel="noopener">Obj中国的#1</a></p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>文中只写了3钟方法，后来我在用的时候要用到其他数据源方法的时候想，为什么不把其他方法也写进去。<br>把数据源完全分离开来。<br>例如 Section的title<br>接口方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSelectIndexTitle:(NSArray *)selectIndexTitles;</span><br></pre></td></tr></table></figure>
<p>用一个数据接收便可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSectionTitle:(NSArray *)groupTitles</span><br><span class="line">&#123;</span><br><span class="line">	self.groupTitles = groupTitles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在titleForHeaderInSection中调用即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">	NSString *title = self.groupTitles[section];</span><br><span class="line">	return title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ascen Zhong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/归档">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ascen Zhong</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
