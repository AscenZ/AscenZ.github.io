<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">














<meta name="description" content="Ascen的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Ascen的羽毛">
<meta property="og:url" content="http://ascen.me/blog/index.html">
<meta property="og:site_name" content="Ascen的羽毛">
<meta property="og:description" content="Ascen的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ascen的羽毛">
<meta name="twitter:description" content="Ascen的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ascen.me/blog/"/>





  <title>Ascen的羽毛</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ascen的羽毛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/首页" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/关于我" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/归档" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2018/08/05/go_parallelism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/05/go_parallelism/" itemprop="url">Go并发初步学习</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T17:37:31+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发-concurrent-与并行-parallelism"><a href="#并发-concurrent-与并行-parallelism" class="headerlink" title="并发(concurrent)与并行(parallelism)"></a>并发(concurrent)与并行(parallelism)</h3><p>并发就是一个处理器同时处理多个任务，不是真正的同时处理，需要在多线程中快速切换，由于切换速度非常快造成同时的假象<br>并行就是真正的同时发生，一般是多个处理器或者多核处理器同时处理多个任务</p>
<p>这张图很有概括性，图来自网上</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-27-185928.jpg" alt="ascen.me_go"></p>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>在Go语言中，没有线程的概念，并发编程最小的调度单位是goroutine，而且本身就很小，创建一个goroutine只有几KB</p>
<p>用法也非常简单，只需要在函数前面加一个 go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test()	//让test()并发运行</span><br></pre></td></tr></table></figure>
<p>但是有一个问题就是mian函数不会等待并发执行的任务，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	fmt.Println(&quot;test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	go test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话是得不到输出的，因为在test()结束之前，mian函数已经结束了。<br>需要在mian函数也添加一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(2 * time.Second)	</span><br><span class="line">//如果也是1秒的话结果不一定，可能主函数先完也可能test函数先完</span><br></pre></td></tr></table></figure>
<p>这里就要并发运行的函数能够告诉主函数，我运行完了，你现在才可以运行完，所以就要用到管道(channel)，</p>
<h3 id="管道-channel"><a href="#管道-channel" class="headerlink" title="管道 channel"></a>管道 channel</h3><p>官方文档叫信道，都一样，只是一条传递信息的通道<br>管道的创建方式有两种，带缓冲和不带缓冲的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 := make(chan int)	//不带缓冲的int管道</span><br><span class="line">c2 := make(chan int, 2)	//缓冲为2的int管道，可以缓冲两个int</span><br></pre></td></tr></table></figure>
<p>刚才的例子可以改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">	fmt.Println(&quot;test&quot;)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	go test()</span><br><span class="line">	&lt;-c	//阻塞直到收到值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管道若不带缓冲，那么在管道中没有数据的话，接收方就会阻塞直到有值。如果发送者还要发送值的话，要等管道中的值被接收之后（也就是清空管道了）才能继续发送。若管道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
<p>这里的缓存也是结构应该也是队列，先进先出</p>
<p>直接读取管道中的内容的话只能读取一个值，可以使用for-range来读取管道，但是如果读完了管道中的内容之后就会阻塞，所以需要在连续发送完使用close(chan)来管道</p>
<p>举个简单的例子，使用匿名函数（闭包）来并发运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line">go func()&#123;</span><br><span class="line">	fmt.Println(&quot;go func&quot;)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2</span><br><span class="line">	close(c)	//如果没有这句就会形成死锁(deadlock)</span><br><span class="line">&#125;()</span><br><span class="line">for v := range c &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func</span><br></pre></td></tr></table></figure>
<p>如果不用for-range读取管道的话，是读取不到2的</p>
<p>一般用带缓存的队列可以用来限制吞吐量</p>
<h4 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h4><p>如果计算过程被分为几个独立执行的过程，每个过程可以在管道中发送信号，从而实现并行处理</p>
<p>这个例子取自 《实效Go编程》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Vector []float64</span><br><span class="line"></span><br><span class="line">func (v Vector) DoSomething(i, n int, u Vector, c chan int) &#123;</span><br><span class="line">	for ; i &lt; n; i++ &#123;</span><br><span class="line">		v[i] += u.Op(v[i])</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- 1	//发信号表示这一块计算完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">const NCPU = 4  // CPU核心数</span><br><span class="line"></span><br><span class="line">func (v Vector) DoAll(u Vector) &#123;</span><br><span class="line">	c := make(chan int, NCPU)  // 缓冲区是可选的，但明显用上更好</span><br><span class="line">	//任务分成NCPU个部分</span><br><span class="line">	for i := 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">		go v.DoSomething(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)</span><br><span class="line">	&#125;</span><br><span class="line">	// 排空信道。</span><br><span class="line">	for i := 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">		&lt;-c    // 等待任务完成</span><br><span class="line">	&#125;</span><br><span class="line">	// 一切完成。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go默认不会并行，如果要开启并行的话，在运行你的工作时将 GOMAXPROCS 环境变量设为你要使用的核心数， 要么导入 runtime 包并调用 runtime.GOMAXPROCS(NCPU)。 runtime.NumCPU() 的值可能很有用，它会返回当前机器的逻辑CPU核心数。</p>
<h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h4><p>前面channel的作用是等到所有goroutine运行完之后再结束主程序<br>在sync包里面有一个WaitGroup 同样可以实现这样的功能</p>
<p>WaitGroup有3个方法</p>
<p>Add(delta int) //添加或者减少等待goroutine的数量<br>Done() //完成，相当于Add(-1)<br>Wait() //执行阻塞，直到所有WaitGroup数量变成0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func mian()&#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.add(10)	//添加10个goroutine事件</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go Go(&amp;wg, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()	//等待直到完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Go(wg *sync.WaitGroup, index int)&#123;</span><br><span class="line">	a := 1</span><br><span class="line">	for i := 0;i &lt; 1000;i++ &#123;</span><br><span class="line">		a += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(index, a)</span><br><span class="line">	wg.Done()	//本次事件完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select是一个控制结构，类似switch，但是是随机执行一个可运行的case，如果没有case可运行那就会阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c1 := make (chan int, 1)</span><br><span class="line">c2 := make (chan int, 1)</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-c1:</span><br><span class="line">    fmt.Println(&quot;c1&quot;)</span><br><span class="line">case &lt;-c2:</span><br><span class="line">    fmt.Println(&quot;c2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果ch1，ch2 都执行完任务，之后就要关闭管道，防止一直阻塞</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go语言中的并发编程很多东西好像写起来很简单，但是可以有很多种高深的写法，能做很多事情。还有很多东西要学习，并发也还要深入的学习。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://go-zh.org/doc/effective_go.html#Go%E7%A8%8B" target="_blank" rel="noopener">实效Go编程-goroutine部分</a><br>Go编程基础视频goroutine部分</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2018/08/03/2016_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/03/2016_summary/" itemprop="url">2016年度总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-03T21:56:26+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/总结报告/" itemprop="url" rel="index">
                    <span itemprop="name">总结报告</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="回顾2016"><a href="#回顾2016" class="headerlink" title="回顾2016"></a>回顾2016</h2><p>2016是有点蛋疼的一年</p>
<h3 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h3><p>2016是大三下学期到大四上学期。刚开始差不多一月多开始的项目“初恋”，由于过年拖了一段时间，然后3月回学校就全力开始开发。中途项目由MVC转向MVVM，也拖了一下我的进度，学习MVVM的一些机制和学习函数式编程。但是有了初步的了解之后就觉得MVVM比MVC好很多，结构清晰很多。</p>
<p>从头开始做“初恋”也让我对产品有了一些理解。产品经理要想好需求，写需求文档和画好原型图，UI要根据原型图画好标注图，配色的一些控件的样式都是UI来设计的，每一个图上面的空间的距离都要有多少像素，等拿到标注图我们程序员就可以开始开发了。首先要开始架构好整个APP，这对于一个初级的程序员真是难度太大了。我们刚开始先写了一些界面，到了要和后台交互的时候要开始写接口文档了，这过程真的学到很多东西。</p>
<p>后来大四就让师弟接手了全部开发，现在由于经历了太多任产品经理以及初期开发的代码的一些问题，整个项目要重构。这也是我没想到的，看来还是太年轻。</p>
<h3 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h3><p>今年学了Cocos2d-x，发现大多数做界面的框架、引擎都有一些共同点，基本都是封装好控件让你来用。而Cocos2d-x之前更是模仿cocos2d写的，有些底层机制例如内存管理机制都是一样的。</p>
<p>学Cocos2d-x的时候是用C++写的，又跑去看了一遍C++，这门复杂的语言还真是复杂。后来我又学了Lua语言，脚本语言真是轻便，我只能用这个词来形容，处理一些上层的业务非常爽快。</p>
<p>在iOS方面，更注重基础和底层，一直在看这方面的文章。还有其他基础，C++和算法，特别是算法，感觉我这方面比较薄弱，以后还会花更多时间来研究。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>感情受挫。😝</p>
<p>其他还好，每天跑步3KM，希望能坚持下去。<br>除了跑步还要锻炼，我要六块腹肌！！！👊<br>开始弹吉他，也买了自己的吉他，希望能成为一个高手😆 也希望能坚持下去。<br>还有在最后一个月报了驾照，刚过了科目一。希望两个月内能拿到驾照吧。</p>
<h3 id="展望2017"><a href="#展望2017" class="headerlink" title="展望2017"></a>展望2017</h3><p>技术<br>有很多想学的东西。注定是要奋斗的一年。<br>想学一下后台，决定要去学GO语言<br>决定要学做一个即时通讯的APP，要看这方面的知识，目前想是看XMPP<br>然后iOS除了要抓底层还要学一些新的库，现在突然多了好多新东西<br>还有就是Cocos2d-x，想做一个自己的游戏！</p>
<h3 id="要买的东西"><a href="#要买的东西" class="headerlink" title="要买的东西"></a>要买的东西</h3><p>这些就定为2017的小目标吧<br>因为要跑步，要先买双跑步鞋<br>然后台式显卡坏了，想换一块好一点的显卡<br>想买一块手表，还有智能手环</p>
<h3 id="2017-加油！"><a href="#2017-加油！" class="headerlink" title="2017 加油！"></a>2017 加油！</h3><p>2017会更好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2018/01/01/2017_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/01/2017_summary/" itemprop="url">2017又结束啦感觉过的挺迷茫的还是总结一下吧</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T21:25:23+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/年度总结/" itemprop="url" rel="index">
                    <span itemprop="name">年度总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="学习想法"><a href="#学习想法" class="headerlink" title="学习想法"></a>学习想法</h3><p>在二月份出来实习的时候进了个小公司，公司虽小但是技术栈还是挺先进的，学到了很多新知识，也让我一些学习有了想法上的改变。像之前做项目的时候，我们仅仅是专注于一端，只关注一端，你给我接口，我拿到数据展示便可。之前我也没关注过后端，在公司实习之前才知道<code>RESTful API</code>这种API 设计模式</p>
<p>不仅如此，当你发现了一个新的领域（虽然很小），你就会发现其他东西，我学习了<code>RESTful API</code>设计，然后其实还有更先进更复杂的<code>graphQL</code>，了解后才发现这东西并不适合小项目，学习成本高，需要前后端配合度高。还了解到了网络通信也不只有API调用这么简单，还有RPC这些，还有待深入了解。</p>
<p>关于数据格式，之前以为只有JSON，XML，因为只用过这些，后来因为项目中有用到 <code>Protocol Buffer</code>，才发现还有这么多数据传输格式。刚开始知道有protobuf这种东西的时候，我就想那这种数据格式数据量那么小，为什么还有那么多项目用JSON，后来发现还是各有其优劣性，protobuf是二进制流传输，数据量很小，但是可读性差，适合做IM的数据格式。</p>
<p>实习的时候接触了很多新知识，让我意识到懂的还是太少，需要不断的学习还能了解更多更全面的知识，而我对自己的定位也是从一个iOS开发工程师变为一个工程师，一个项目前后端要用到什么技术都要知道怎么用，而会用就要去了解这种技术的思想，甚至底层实现。</p>
<h3 id="关于编程语言"><a href="#关于编程语言" class="headerlink" title="关于编程语言"></a>关于编程语言</h3><h4 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h4><p>因为之前不想总局限于前端，觉得需要学一门后端语言，那时候简单学过可以开发服务端的有c++，java，python，后来对比了很多语言，最后还是选择了Go语言。其实已经学过很多东西了，所以过了一遍官方教程还有社区的一些教程就快速上手了，两个星期。再花时间了解一些web框架，orm框架，基本就能开始开发服务端了。学了Go语言感觉还是挺好的，性能好并且语法也比c++简单很多，当然Go的错误处理还是挺蛋疼的，但是瑕不掩瑜，这确实是能让我喜欢的一门语言。</p>
<h4 id="Shell-Script"><a href="#Shell-Script" class="headerlink" title="Shell Script"></a>Shell Script</h4><p>严格来说都不知道这算不算一门变成语言。学这个是因为当初在想我竟然还不会一门脚本语言，我需要写一些脚本。然后就系统的学了一遍，其实有些语法挺恶心的<br>但是用写一些小脚本来实现自己想要的一些功能还是挺有意思的，写了自己的App自动化打包，导出，上传，最后通知的脚本，到现在也还在用</p>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>写一些本地工具脚本可以用用shell脚本，但是想写一些爬虫的话，shell脚本感觉挺无奈的，解析json什么的都非常麻烦，所以在大三大概学过一遍python之后到现在都没碰过，最近又开始系统的学了一遍，准备写一些爬虫，workflow什么的</p>
<p>学了那么多语言之后，感觉编程语言再也不是编程的障碍了，不同的只是语法和一些设计思想，最重要的还是设计模式跟编程思想</p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>公司项目就不说了</p>
<h4 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h4><p>刚开始想的时候到底要做什么，后来想就做一个及时通讯App吧，服务端和iOS端。服务端当时就是学了Golang，iOS端还是用OC吧，然后纠结了一些技术选型的问题，即时通信那要用什么通讯协议呢，接触过的有XMPP，当时这个直接用起来肯定太简单了，什么都搭好了。还有WebSocket，后来想，用这个还不如自己从底层Socket开始搭，数据格式就用了谷歌的<code>Protocol Buffer</code><br>然后开始我是纠结用TCP还是UDP的时候，那时候有很多想法，为了追求完美，最后传输的时候用UDP，用TCP来辅助，当时跟一个大佬说了这个想法还给鄙视了🤣，说为什么不直接用TCP。我觉得我的尝试还是没错的<br>其实这个项目只做了十几二十天，最后完成度不高，最后答辩的时候用了真机和模拟器来演示聊天，结果因为还没做通知给老师喷说不是真正的即时聊天<br>总之这个项目让我学到了很多东西，前端后台的</p>
<p><a href="https://github.com/AscenZ/Hey" target="_blank" rel="noopener">https://github.com/AscenZ/Hey</a></p>
<h4 id="Swift项目"><a href="#Swift项目" class="headerlink" title="Swift项目"></a>Swift项目</h4><p>虽然学过好几次Swift，用Swift写过一些Demo，但是还没用Swift写过项目，在八九月的时候接了朋友的一个小项目，那时候就想用Swift写吧，总体来说，用Swift写项目代码很简洁，API意思都没太大变化，都是简洁版，但是编译器支持还是太烂了，RxSwift用的还是不够RAC好，这个是重点，还是要花更多的时间去学RxSwift</p>
<h3 id="2018学习目标"><a href="#2018学习目标" class="headerlink" title="2018学习目标"></a>2018学习目标</h3><p>现在主要大方向还是iOS正向/逆向开发，觉得有趣不想放弃的有Golang后台开发，Python脚本开发，这些都是主要的学习方向，总体方向是不局限于iOS，而是要把自己当成一个工程师，向全栈发展</p>
<h4 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h4><p>买了《iOS应用逆向工程》目前只看了一部分，先看完这本书，再实践实践，学习过程中也更帮助我了解了iOS系统的底层</p>
<h4 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h4><p>虽然现在苹果并不鼓励非Native开发，感觉无论怎么样还是要学学的，学学设计思想，还有学学JavaScript🤣</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>现在做了个非常庞大的项目，感觉用到了很多设计模式，可能会用，但是还是不能系统的概括出来，还是要系统的学习一下设计模式</p>
<p>如果还有感兴趣的技术也会毫无犹豫的去学，总之不能放弃学习</p>
<h3 id="2017看的书"><a href="#2017看的书" class="headerlink" title="2017看的书"></a>2017看的书</h3><p>实习的时候每天要坐两个钟地铁，我就想在地铁上做点什么好呢，后来想，还是听听书吧，刚开始找了几本热门的书听，后来觉得听的不过瘾，就看了很多书，觉得很有意思，果然即使工作了还是不能放弃阅读</p>
<p>2017读完的书：<br>《解忧杂货铺》<br>《岛上书店》<br>《时光倒流的女孩》<br>《被掩埋的巨人》<br>《十一字杀人》<br>《仁医》<br>《时生》<br>《孤儿列车》<br>《倒悬的地平线》</p>
<p><img src="http://on1svswrl.bkt.clouddn.com/IMG_3585.jpg" alt="读完的书"></p>
<p>2018也要读更多的书</p>
<h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><p>2016年开始跑步，2017年才跑了350KM，感觉还是有些懒散，2018继续加油，给自己立个目标，不低于500KM吧！！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2017虽然过的挺迷茫的，当时还是挺有意思的一年吧，踏入了社会，见识到了更多，学到了更多，也意识到自己的一些不足。希望2018能学到更多东西，更多技术吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2017/04/15/rac_pit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/04/15/rac_pit/" itemprop="url">RAC的一些坑</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-15T20:37:12+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记得第一个项目用RAC的时候，对MVVM还不理解，通用对RAC也不理解<br>最近项目中一直在用RAC，OC版的（之前叫ReactiveCocoa，现在分离出OC版的ReactiveObjc），也算入门了吧，也终于理解了MVVM<br>现在用的越多，发现RAC一些用法是有些坑的，总结一下</p>
<h3 id="关于Model"><a href="#关于Model" class="headerlink" title="关于Model"></a>关于Model</h3><p>刚开始学习MVVM的时候，我一直以为一个整体是四部分，Model+View+ViewModel+Controller，这里的Model不是指的通用Model（例如User,Orders那些），而是指在MVC中例如TableView中的Model，这个在MVVM中是可选的（即可有可无），我也不清楚有没有一个标准说规定要有或者不能有，我局的如果MVC扩展成MVVM的时候又不想改动太大，那可以保留，如果直接从MVVM开始的话，还是不用写的好</p>
<p>因为ViewModel的作用完全可以包括了Model的作用，首先我们要明白Controller只是定义View和绑定数据，而数据处理放在ViewModel，而数据我们可以在ViewModel中定义只读的属性(readonly)来提供，所以一个整体的话一般就只有Controller+View(可能直接在Controller里面定义了)+ ViewModel</p>
<h3 id="关于绑定数据"><a href="#关于绑定数据" class="headerlink" title="关于绑定数据"></a>关于绑定数据</h3><p>其实也不是说用MVVM就一定要要RAC，你可以用KVO啊（如果不嫌麻烦的话），当然RAC底层就是用KVO来实现的，只不过RAC封装的更好用，使用更简便，让你轻轻松松就绑定了数据</p>
<p>我们先来看看 RAC(…) 和 RACObserve(…) 这两个宏，一般来说我们需要绑定数据的话，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.label, text) = RACObserve(self.viewModel, text)</span><br></pre></td></tr></table></figure>
<p>这样我们就把ViewModel上的text绑定到了一个label上，这是最简单的用法，关于底层那些信号流机制我就不说了，说一下我碰到的一个坑，例如现在有一个输入框，我拿到了信息后要发起请求，发起请求的入口当然是在ViewModel中，所以我们要这样绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, text) = self.textField.rac_textSignal;</span><br></pre></td></tr></table></figure>
<p>这样就绑定好了，然后产品经理给你提了个需求，这是个电话输入框，你在旁边加个通讯录按钮，点完可以进通讯录读取号码显示在输入框上，然后等你写完后你发现数据绑定失效了（当然不是失效了），我们来看看rac_textSignal的实现，其中一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self rac_signalForControlEvents:UIControlEventAllEditingEvents]</span><br></pre></td></tr></table></figure>
<p>原来这个信号只监听所有编辑事件，这种从通讯录读取的是 赋值事件，那还要这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, text) = RACObserve(self.textField, text)</span><br></pre></td></tr></table></figure>
<p>刚开始学RAC的时候我以为这两种方式是一样的，但是 RACObserve(…) 是监听这个属性本身，往底层说 应该是监听这个属性的内存地址，其实我们想要的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, text) = [self.textField.rac_textSignal merge:RACObserve(self.textField, text)]</span><br></pre></td></tr></table></figure>
<p>然后产品经理说这个界面信息展示太多了还要输入，你弄一个可点击的输入框，一点就跳到另一个界面可以输入名字，电话号码那些信息，也要有通讯录按钮可以拉取名字，还要有历史记录，号码，输入完点确定跳转回来再展示出来就行了，对了，已经有信息的时候点进去 输入框也要默认有信息</p>
<p>这时候，我们就要开始改这里的绑定数据，已经有信息的时候点进去要输入框要有默认信息，那就这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.textField.text = self.viewModel.text;</span><br><span class="line">RAC(self.viewModel, text) = [self.textField.rac_textSignal merge:RACObserve(self.textField, text)]</span><br></pre></td></tr></table></figure>
<p>可是还要有历史记录，持久化那只能在ViewModel里面做，那就用双向绑定吧<br>在RAC中双向绑定用 RACChannel ，也有特定的宏，这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(self.viewModel, text) = RACChannelTo(self.textField, text)</span><br></pre></td></tr></table></figure>
<p>这样从通讯录拉取信息并且绑定到ViewModel的属性上了，但是我们发现输入的时候又绑定不了了，那就按上面的加一句这个？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(self.viewModel, text) = self.textField.rac_newTextChannel;</span><br></pre></td></tr></table></figure>
<p>然后发现输入事件绑定好了，但是从通讯录一拉取信息，发现app crash了，看了下线程栈，死循环了</p>
<p>那应该是 双向绑定了两次导致信号流来回触发监听事件，具体细节可以看这篇文章<br>RAC 中的双向数据绑定 RACChannel</p>
<p>所以就不能这样实现，双向绑定还有一些其他坑，假如点进去的界面还要输入详细地址，那我们用一个 textView 来做，然后发现 textView 并没有实现 rac_newTextChannel，这就尴尬了</p>
<p>实质上，RACChannelTo(…) 这个宏得到的是一个 RACChannelTerminal ，这个 RACChannelTerminal 相当于网络连接中的socket，只是一端，而让两个 RACChannelTerminal 则相当于让这两个 RACChannelTerminal相互订阅，那我们可以自定义一个 RACChannelTerminal吗？RAC并不允许你这么做，RACChannelTerminal的初始化方法是私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//仅声明在.m文件</span><br><span class="line">- (id)initWithValues:(RACSignal *)values otherTerminal:(id&lt;RACSubscriber&gt;)otherTerminal;</span><br></pre></td></tr></table></figure>
<p>无奈，我还是放弃使用双向绑定数据了，原来怎么写就怎么写吧</p>
<h3 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h3><p>其实RAC中已经写好取代原生代理的方法了，但是有一个很大的缺点，由于信号流是单向流动的，在订阅后实现你想要实现的代码，但是无法返回值！！也就是说，你无法用RAC写有返回值的代理方法</p>
<p>现在产品经理叫你在实现的 号码输入框，地址输入框添加键盘事件，return key 上面的变成next，最后的变成 done，点了后要收起键盘</p>
<p>我们要用到 textField 和 textView 的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;</span><br></pre></td></tr></table></figure>
<p>有返回值，所以就直接写， textView点击done收起键盘，那就这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text &#123;</span><br><span class="line">    if([text isEqualToString:@&quot;\n&quot;]) &#123;</span><br><span class="line">        [textView resignFirstResponder];</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后设置代理等于self，写上协议</p>
<p>运行一下，OK，这个功能就实现了<br>但是你发现textView的数据绑定挂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.textView.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line">	NSLog(@&quot;text--%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>订阅信号发现 信号完全挂了<br>百思不得其解，轮到搜索引擎出场了，Google # RAC textView textSignal<br>然后发现RAC的一条issue<br>rac_textSignal not work on UITextView #1981</p>
<p>你发现他和你一样是设置了代理后信号就没用了，然后看到这个</p>
<p>先设置代理就行了吗？！然后你试了一下，发现就是这个问题<br>RAC特么的还管设置代理和绑定数据先后问题！！！为什么 textField 设置在先后都可以，而 textView不行呢！！！好吧，都是RAC的错</p>
<p>后来我看了一下RAC代理的实现，原来他并不是把Block放到那个方法里面去执行，而是使用 Swizzle来hook那个方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RAC还是很强大的，很多思想值得学习，但是也有一些小坑，总之还有还多东西要学习</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2017/02/19/restful_api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/02/19/restful_api/" itemprop="url">基于RESTful API的设计模式小实践</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-19T20:27:29+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST是REpresentational State Transfer的缩写，表现层状态转移，这里的表现层指的是资源<br>我们设计API的时候每一个url都要指向一个资源<br>例如现在有一个订单（资源）<br><a href="http://example.com/api/v1/orders" target="_blank" rel="noopener">http://example.com/api/v1/orders</a><br>而我们的操作由HTTP的请求方法来决定<br>v1为API版本号</p>
<ul>
<li>GET <a href="http://example.com/api/v1/orders" target="_blank" rel="noopener">http://example.com/api/v1/orders</a><br>就是获取所有的订单</li>
<li>GET <a href="http://example.com/api/v1/orders/123" target="_blank" rel="noopener">http://example.com/api/v1/orders/123</a><br>获取ID为123的订单</li>
<li>POST <a href="http://example.com/api/v1/orders" target="_blank" rel="noopener">http://example.com/api/v1/orders</a><br>创建一个新的订单</li>
<li>POST <a href="http://example.com/api/v1/orders/123" target="_blank" rel="noopener">http://example.com/api/v1/orders/123</a><br>更新ID为123的订单</li>
<li>PATCH <a href="http://example.com/api/v1/orders/123" target="_blank" rel="noopener">http://example.com/api/v1/orders/123</a><br>修改ID为123的订单</li>
<li>DELETE <a href="http://example.com/api/v1/orders/123" target="_blank" rel="noopener">http://example.com/api/v1/orders/123</a><br>删除ID为123的订单<br>也可以在后面添加参数修改订单状态</li>
<li>POST <a href="http://example.com/api/v1/orders/123/cancel" target="_blank" rel="noopener">http://example.com/api/v1/orders/123/cancel</a><br>设置这个订单的状态为取消</li>
<li>POST <a href="http://example.com/api/v1/orders/123/finish" target="_blank" rel="noopener">http://example.com/api/v1/orders/123/finish</a><br>设置这个订单的状态为完成<br>总之都是围绕 <a href="http://example.com/api/v1/orders" target="_blank" rel="noopener">http://example.com/api/v1/orders</a> 这个URL来设计，一句话总结就是使用URL来定位资源，使用HTTP请求方法来操作</li>
</ul>
<h3 id="小实践"><a href="#小实践" class="headerlink" title="小实践"></a>小实践</h3><p>接下来我用Go简单的写了个小服务器<br>定义了一个Orders类型，有Id，Name,Price三个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Orders struct &#123;</span><br><span class="line">	Id    int</span><br><span class="line">	Name  string</span><br><span class="line">	Price int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RESTful相关处理url使用的是github.com/gorilla/mux这个库，非常简便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(&quot;/api/v1/orders/&#123;id&#125;&quot;, getOrders).Methods(&quot;GET&quot;)</span><br><span class="line">r.HandleFunc(&quot;/api/v1/orders&quot;, getOrders).Methods(&quot;GET&quot;)</span><br><span class="line">r.HandleFunc(&quot;/api/v1/orders&quot;, createAnOrders).Methods(&quot;POST&quot;)</span><br><span class="line">r.HandleFunc(&quot;/api/v1/orders/&#123;id&#125;&quot;, updateOrders).Methods(&quot;PATCH&quot;)</span><br><span class="line">r.HandleFunc(&quot;/api/v1/orders/&#123;id&#125;&quot;, delteOrders).Methods(&quot;DELETE&quot;)</span><br></pre></td></tr></table></figure>
<p>数据库用的是postgreSQL，用了对象关系映射库gorm<br>然后简单的存了点模拟数据</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-072547.jpg" alt="ascen.me_restful"></p>
<p>服务器监听的是8080端口<br>然后我就不写前端了，直接使用curl命令在控制台操作</p>
<p>使用GET操作获得所有订单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8080/api/v1/orders</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-134318.jpg" alt="ascen.me_restful"></p>
<p>使用GET操作加上ID获取一个订单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取id为123的订单</span><br><span class="line">curl localhost:8080/api/v1/orders/123</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-134257.jpg" alt="ascen.me_restfule"></p>
<p>使用POST创建订单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data id=666 --data name=&quot;test123&quot; --data price=998 localhost:8080/api/v1/orders</span><br></pre></td></tr></table></figure>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-134444.jpg" alt="ascen.me_restfule"></p>
<p>这是服务器的输出</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-134523.jpg" alt="ascen.me_restfule"></p>
<p>数据库可以看到</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-133845.jpg" alt="ascen.me_restfule"></p>
<p>使用DELETE操作删除一个订单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE localhost:8080/api/v1/orders/123</span><br></pre></td></tr></table></figure></p>
<p>数据库更新</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-134802.jpg" alt="ascen.me_restfule"></p>
<p>使用PATCH操作修改订单的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PATCH --data name=haobang localhost:8080/api/v1/orders/234</span><br></pre></td></tr></table></figure></p>
<p>数据库</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-02-19-135159.jpg" alt="ascen.me_restfule"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2017/01/27/go_interface_reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/01/27/go_interface_reflection/" itemprop="url">Go语言中的接口和反射</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-27T17:32:59+08:00">
                2017-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><p>接口就是一个或多个方法的集合，若某个类型的对象实现了所有的方法，那么这个对象就实现了这个接口<br>接口还可以存储值，只要这个类型的对象实现了这个接口，那么这个接口就可以存储这个类型的对象<br>又因为空接口(interface{})没有一个方法，每个类型的对象至少实现了0个或者0个以上的方法，所以空接口能存储任何值</p>
<p>既然接口可以被很多对象实现，那么接口就可以存储很多类型的对象或值，那函数的形参就可以用 接口类型，这样函数就可以接收实现了这个接口的多种类型的对象或值</p>
<p>那现在有一个以接口为形参的函数，要怎么知道这个接口是什么类型的呢？</p>
<p>我们可以这样判断，加入函数的形参是一个接口B类型的值b，我们需要知道b是不是A类型的，并且判断A对象是否实现了B接口</p>
<p>我们可以使用接口中的 .(type) 来判断类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test(b B) &#123;</span><br><span class="line">	if a, ok := b.(A); ok &#123;</span><br><span class="line">		fmt.Println(&quot;a实现了接口B&quot;,a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前，形参也可以是空接口<br>空接口可以接收任何值，一个小例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x float32 = 5.3</span><br><span class="line">var i interface&#123;&#125;</span><br><span class="line">i = x</span><br><span class="line">switch i := i.(type) &#123;</span><br><span class="line">case float64:</span><br><span class="line">	fmt.Println(&quot;float64&quot;,i)</span><br><span class="line">case float32:</span><br><span class="line">	fmt.Println(&quot;float32&quot;,i)</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;who care&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line">//输出 float32 5.3</span><br></pre></td></tr></table></figure>
<h4 id="内嵌接口"><a href="#内嵌接口" class="headerlink" title="内嵌接口"></a>内嵌接口</h4><p>和结构体中的匿名类型差不多<br>io包中的Writer和Reader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">	Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">	Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadWriter 接口结合了 Reader 和 Writer 接口。</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射 reflection"></a>反射 reflection</h3><h4 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a>从接口值到反射对象</h4><p>类型-值<br>Type Value<br>reflect.TypeOf() 获取的是reflect.Type<br>reflect.ValueOf() 获取的是reflect.Value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// TypeOf 返回 interface&#123;&#125; 中的值的反射类型Type</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type</span><br></pre></td></tr></table></figure>
<p>接收参数的空接口类型（interface{}），因为任何值都有0个或0个以上的方法，可以说都实现了空接口，可以空接口可以接收任何值</p>
<p>reflect中有一个Kind方法，Kind() 和 TypeOf()都是返回类型，但是又有区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type myInt int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var x myInt = 5</span><br><span class="line">	a := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(&quot;Type:&quot;, reflect.TypeOf(x), &quot;Kind:&quot;, a.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type: main.myInt Kind: int</span><br></pre></td></tr></table></figure>
<p>Type能识别自定义的类型，Kind只能识别到底层的类型</p>
<p>关于结构体的反射对象到值<br>一个简单的例子(取自官方文档）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type T struct &#123;</span><br><span class="line">    A int</span><br><span class="line">    B string</span><br><span class="line">&#125;</span><br><span class="line">t := T&#123;23, &quot;skidoo&quot;&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line">for i := 0; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: A int = 23</span><br><span class="line">1: B string = skidoo</span><br></pre></td></tr></table></figure>
<h4 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a>从反射对象到接口值</h4><p>给了一个 reflect.Value</p>
<p>有一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) Interface() interface&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x int = 5</span><br><span class="line">a := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(a.Interface())</span><br></pre></td></tr></table></figure>
<p>要修改反射对象，其值必须可设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 5.4</span><br><span class="line">a := reflect.ValueOf(x)</span><br><span class="line">a.SetFloat(5.4)</span><br></pre></td></tr></table></figure>
<p>调用SetFloat()之后会报panic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetFloat using unaddressable value</span><br></pre></td></tr></table></figure>
<p>无论是想改x，还是x的副本a 这样都无法修改<br>但是如果想修改x，可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 5.4</span><br><span class="line">//取x的引用</span><br><span class="line">a := reflect.ValueOf(&amp;x)</span><br><span class="line">c := a.Elem()</span><br><span class="line">//这时候c是可以调用`setFloat()`的，它的canSet()是true</span><br><span class="line">c.setFloat(11.1)</span><br><span class="line">fmt.Println(&quot;c:&quot;, c, &quot;x:&quot;, x)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c: 11.1 x: 11.1</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jb51.net/article/56812.htm" target="_blank" rel="noopener">Go语言interface详解</a><br><a href="https://blog.go-zh.org/laws-of-reflection" target="_blank" rel="noopener">反射三法则 - Go博客</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2017/01/08/cpp_raii_smart_ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/01/08/cpp_raii_smart_ptr/" itemprop="url">C++ RAII与智能指针</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T16:11:47+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是RAII"><a href="#什么是RAII" class="headerlink" title="什么是RAII"></a>什么是RAII</h3><p>资源获取即初始化 (Resource Acquisition Is Initialization, RAII)，RAII是一种资源管理机制，资源的有效期与持有资源的对象生命期严格绑定，即由对象的构造函数完成资源的分配，由析构函数完成资源的释放，总结一句话就是 用对象来管理资源</p>
<h3 id="RAII实现原理"><a href="#RAII实现原理" class="headerlink" title="RAII实现原理"></a>RAII实现原理</h3><p>当一个对象离开作用域的时候就会被释放，会调用这个对象类的析构函数，这都是自动管理的，不需要我们手动调用。所以我们可以把资源封装到类的内部，当需要用资源的时候初始化对象即可，当对象被释放的时候资源也会被释放</p>
<p>看一个小例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class ArrayOperation</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    ArrayOperation()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Array = new int [10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void InitArray()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            *(m_Array + i) = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void ShowArray()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt;10; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;m_Array[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ArrayOperation()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl;</span><br><span class="line">        if (m_Array != NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] m_Array;</span><br><span class="line">            m_Array = NULL ;</span><br><span class="line">            cout &lt;&lt; &quot;m_Array is released&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private :</span><br><span class="line">    int *m_Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    ArrayOperation arrayOp;</span><br><span class="line">    arrayOp.InitArray();</span><br><span class="line">    arrayOp.ShowArray();</span><br><span class="line">    cout &lt;&lt; &quot;test end&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    cout &lt;&lt; &quot;return 0&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-06-214110.jpg" alt="ascen.me_cpp_raii"></p>
<p>可以看到在test函数结束之后会释放对象arrayOp，然后会调用ArrayOperation的析构函数，会释放掉指针</p>
<p>简单说明一下，创建arrayOp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayOperation arrayOp;</span><br><span class="line">//相当于 ArrayOperation arrayOp = ArrayOperation();</span><br><span class="line">//隐式、显示调用的区别</span><br></pre></td></tr></table></figure>
<p>是在栈中分配内存，如果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayOperation* arrayOp = new ArrayOperation();</span><br></pre></td></tr></table></figure>
<p>则是在堆中分配内存，如果不</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete arrayOp;</span><br></pre></td></tr></table></figure>
<p>则不会调用析构函数</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p>auto_ptr的特性就是在栈上构建对象，在离开作用范围时会自动析构</p>
<p>上面的例子可以改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">	auto_ptr&lt;ArrayOperation&gt; arrayOp(new ArrayOperation);</span><br><span class="line">	//相当于auto_ptr&lt;ArrayOperation&gt; arrayOp(new ArrayOperation());</span><br><span class="line">	arrayOp-&gt;InitArray();</span><br><span class="line">	arrayOp-&gt;ShowArray();</span><br><span class="line">	cout &lt;&lt; &quot;test end&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话不需要 delete arrayOp 也会调用析构函数来释放资源</p>
<p>auto_ptr有一个问题，就是被销毁时会自动删除它指向的对象，所以不能让多个auto_ptr指向同一个对象。如果有多个auto_ptr指针指向同一个对象的话便会多次删除对象。</p>
<p>但是若通过copy构造函数或者 copy assignment 操作符复制它们，它们就会变成null，而复制所得的指针将取得资源的唯一控制权(所有权），注意，是拷贝初始化，或者拷贝赋值才会这样，即发生了拷贝行为即原指针会变为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int*p=new int(0);</span><br><span class="line">auto_ptr&lt;int&gt;ap1(p);</span><br><span class="line">auto_ptr&lt;int&gt;ap2(p);</span><br></pre></td></tr></table></figure>
<p>这样ap1、ap2都指向p所指之物，危险行为，会删除p两次。</p>
<p>如果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int*p=new int(0);</span><br><span class="line">auto_ptr&lt;int&gt;ap1(p);</span><br><span class="line">auto_ptr&lt;int&gt;ap2 = ap1;</span><br><span class="line">//或者 auto_ptr&lt;int&gt; ap2(ap1);</span><br></pre></td></tr></table></figure>
<p>ap2是拷贝初始化，ap1会变为null，ap2指向p所指之物</p>
<p>而且因为auto_ptr的析构函数中删除指针用的是delete,而不是delete [],所以我们不应该用auto_ptr来管理一个数组指针！！</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>share_ptr也是一种智能指针，自动管理对象的释放，并且可以让多个指针指向同一个对象，会有一个iOS ARC中的“引用计数”来记录这个对象被多少指针所引用，如果这个对象的引用计数变为0，则被会自动释放空间</p>
<p>shared_ptr跟auto_ptr一样自动管理对象的释放，并且没有auto_ptr的那些缺点，因为使用了“引用计数”，但是这样也产生了新的问题，那就是循环引用、自引用等问题</p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>由于shared_ptr有了循环引用等问题，于是就有了weak_ptr这种弱引用的指针，不增加引用计数</p>
<p>这里和iOS Property中的机制差不多，很多地方的实现思想都是相似的</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>unique_ptr是只能有一个unique_ptr指向一个对象，因此unique_ptr不支持拷贝和赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p1(new string(&quot;test&quot;));</span><br><span class="line">unique_ptr&lt;string&gt; p2(p1); //拷贝，错误</span><br><span class="line">unique_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p2;	//赋值，错误</span><br></pre></td></tr></table></figure>
<p>不能拷贝或者赋值，但是可以通过 release 或 reset来转换指针的所有权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p2(p1.release); //release将p1置空</span><br><span class="line">unique_ptr&lt;string&gt; p3(new string(&quot;test&quot;));</span><br><span class="line">p2.reset(p3.release);	//reset释放了p2原来指向的内存</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>C++中的RAII机制<br>Effective C++ 第13条款<br>C++ Primer</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2017/01/06/process_thread_multithread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/01/06/process_thread_multithread/" itemprop="url">进程、线程理解及多线程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T22:42:18+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h3><p>进程是正在运行的程序的实例，一个任务就是一个进程<br>如下图，每一个运行的程序就是一个进程，有系统的，也有用户的</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-04-064747.jpg" alt="process"></p>
<h3 id="进程间通信-IPC-Inter-Process-Communication"><a href="#进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信 IPC (Inter-Process Communication)"></a>进程间通信 IPC (Inter-Process Communication)</h3><p>至少两个进程或县城建传送数据或信号的一些技术和方法，进程是彼此隔离的，为了让不同进程互相访问资源并协调工作，所以要进程间通信</p>
<p>主要的IPC方法有</p>
<ul>
<li><p>文件</p>
<p>  每个进程都可以使用文件</p>
</li>
<li><p>信号</p>
<p>  可以通过发送信号给一个线程，操作系统可以终端进程的正常控制流程，任何非原子(nonatomic)操作都会被中断。<br>例如我们在终端运行了某个进程的时候，Ctrl-C发送INT信号，该进程会被终止，Ctrl-Z发送TSTP信号，该进程会被挂起</p>
</li>
<li><p>Socket (Unix domain socket)</p>
<p>  用C语言写成的应用程序开发库，可用于进程间通信。在系统内核里，Socket可以被系统进程引用，两个进程可以同时使用一个Socket来通信</p>
</li>
<li><p>消息队列 Message queue</p>
<p>  可以在进程间通信或在同一进程的不同线程中通信。消息队列是异步的，一个进程通知以一个进程发生了一个事件，不需要等待，但是接收者必须轮询消息队列，才能收到最近的消息</p>
</li>
<li><p>管道</p>
<p>  是一个由标准输入输出链接起来的进程集合，每一个进程的输出被直接作为下一个进程的输入，例如在终端中输入 ls -l | less，这样ls -l的输出作为输入到less分页器中。<br>进程间的通信便是一个进程的输出作为另一个进程输入。</p>
</li>
</ul>
<p>在大多数类UNIX操作系统中，管线上的所有进程同时启动，输入输出流也已经被正确地连接，并且这些进程被调度程序所管理。最为重要的一点就是，所有的UNIX管道和其他管道实现不一样的地方就是缓存的概念：输出进程可能会以每秒5000 byte的速度输出，但是接收进程也许每秒只能接收100 byte，但不会有数据丢失。原因就是管道上游的进程的所有输出都会被放入一个队列中。当下游进程开始接收数据时，操作系统就会将数据从队列传至接收进程，并将传完的数据从队列中移除。当缓存队列空间不足时，上游进程会被终止，直到接收进程读取数据为上游进程腾出空间。在Linux中，缓存队列的大小是65536 byte。</p>
<ul>
<li>信号量 Semaphore</li>
</ul>
<p>计数信号量具备两种操作动作，之前称为 V（又称signal( )）与 P（wait( )）。 V操作会增加信号量 S的数值，P操作会减少它。<br>两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。<br>互斥锁(Mutex)也是这样实现的。信号量也可以用于同步，一般同步信号量的初值为0，互斥信号量的初值为1.</p>
<ul>
<li>共享内存</li>
</ul>
<p>可以被多个进程存取的内存</p>
<h4 id="进程的同步-Synchronization"><a href="#进程的同步-Synchronization" class="headerlink" title="进程的同步 Synchronization"></a>进程的同步 Synchronization</h4><p>进程的同步是解决进程间协作关系的手段，多个线程基于某个条件来协调它们的活动，一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒</p>
<p>主要的同步方法有</p>
<ul>
<li>私有信号量<br>  我觉得用管道和Socket也可以</li>
<li>线程 Thread<br>  每一个进程中至少有一个线程，你看上面的图有的进程甚至有上百个线程</li>
</ul>
<p>线程是进程中的调度单位，例如打开QQ，就运行了一个进程，QQ开一个线程传输文字，开一个线程传输图片，或者下载软件下载东西的时候，开一个线程下载某一部分，再开另一个线程下载另一部分。</p>
<p>同一进程中的多条线程共享该进程的全部系统资源，但是他们都有各自的调用栈，寄存器环境和线程本地存储。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="PThreads-POSIX-Threads"><a href="#PThreads-POSIX-Threads" class="headerlink" title="PThreads ( POSIX Threads )"></a>PThreads ( POSIX Threads )</h4><p>PThreads是基于C语言的多线程方案</p>
<p>创建线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    pthread_t pt;</span><br><span class="line">    pthread_create(&amp;pt, NULL, thread_func, NULL);</span><br><span class="line">    </span><br><span class="line">    pthread_t pt2;</span><br><span class="line">    apt = pthread_create(&amp;pt2, NULL, thread_func2, NULL);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        NSLog(@&quot;1111111111 ---- %d&quot;,i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread_func(void *atgs)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0;i &lt; 10;++i)&#123;</span><br><span class="line">        NSLog(@&quot;2222222222 ---- %d&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread_func2(void *atgs)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0;i &lt; 10;++i)&#123;</span><br><span class="line">        NSLog(@&quot;3333333333 ---- %d&quot;,i);</span><br><span class="line">        if(i == 5)&#123;</span><br><span class="line">            pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pthread_create(..)</code>是创建一个线程的方法，第三个参数需要传入一个C函数指针，OC中的方法不行</p>
<p>上面创建了两个线程，然后在viewDidLoad里面也输出0到10，可以看到结果是3个线程里面的方法随机输出</p>
<p><code>pthread_exit(NULL)</code>是退出当线程，可以看到当i==5的时候退出打印3的线程</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-04-182025.jpg" alt=""></p>
<p><code>pthread_once</code> 表示永远只执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_once_t pot;</span><br><span class="line">pthread_once(&amp;pot, thread_once);</span><br></pre></td></tr></table></figure>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mt;</span><br><span class="line">pthread_mutex_init(&amp;mt, NULL);</span><br><span class="line">//...</span><br><span class="line">pthread_mutex_lock(&amp;mt);</span><br><span class="line">//互斥的操作...</span><br><span class="line">pthread_mutex_unlock(&amp;mt);</span><br></pre></td></tr></table></figure>
<p>简单例子<br>现在有一个方法里面有一个计数cnt自增，并且暂停一秒（模拟方法需要执行很久的时候），有3个线程同时调用这个方法并且输出cnt值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void thread_mutextest(void)&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候sleep(1)完之后几乎3个线程一起读取cnt的值</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-05-104836.jpg" alt="thread"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void thread_mutextest(void)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mt);</span><br><span class="line">    ++cnt;</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果加了互斥锁，每一秒只能有一个线程去读取cnt的值</p>
<p>读写锁<br>互斥锁会把试图进入已保护的临界区的线程都阻塞，即同时只有一个线程持有锁<br>读写锁会根据当前进入临界区的线程是读还是写的属性来判断是否允许线程进入。多个读者可以同时持有锁。</p>
<p>适用于读数据的频率远大于写数据的频率的应用中，这样可以在任何时刻运行多个读线程并发的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_t rwt;</span><br><span class="line">pthread_rwlock_init(&amp;rwt, NULL);</span><br><span class="line"></span><br><span class="line">//读加锁</span><br><span class="line">pthread_rwlock_rdlock(&amp;rwt);</span><br><span class="line"></span><br><span class="line">//写加锁</span><br><span class="line">pthread_rwlock_wrlock(&amp;rwt);</span><br><span class="line"></span><br><span class="line">//读写锁的解锁</span><br><span class="line">pthread_rwlock_unlock(&amp;rwt);</span><br></pre></td></tr></table></figure>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>基本操作就不说了，网上太多文章了，很多都写的很好<br>但是我们来看看<code>dispatch_barrier</code></p>
<p><code>dispatch_barrier</code>是一种屏障，也可以理解成一种锁，它让block里面的任务等待队列(queue)之前的任务执行完之后再执行，执行block里面的任务时，队列后面的任务也要等待。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//创建一个并行队列</span><br><span class="line">dispatch_queue_t dqt = dispatch_queue_create(&quot;concurrent_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(dqt, ^()&#123;</span><br><span class="line">    for(int i = 0;i &lt; 5;++i)&#123;</span><br><span class="line">        NSLog(@&quot;dispatch-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dqt, ^()&#123;</span><br><span class="line">    for(int i = 0;i &lt; 5;++i)&#123;</span><br><span class="line">        NSLog(@&quot;dispatch-2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(dqt, ^()&#123;</span><br><span class="line">    for(int i = 0;i &lt; 5;++i)&#123;</span><br><span class="line">        NSLog(@&quot;dispatch-barrier&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dqt, ^()&#123;</span><br><span class="line">    for(int i = 0;i &lt; 5;++i)&#123;</span><br><span class="line">        NSLog(@&quot;dispatch-3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dqt, ^()&#123;</span><br><span class="line">    for(int i = 0;i &lt; 5;++i)&#123;</span><br><span class="line">        NSLog(@&quot;dispatch-4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2017-01-05-195338.jpg" alt="gcd"></p>
<p>但是在全局队列(dispatch_get_global_queue(..))中不起作用，在自己创建的并行、串行队列中，使用同步、异步都起作用</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.imooc.com/article/11011" target="_blank" rel="noopener">进程和线程定义，概念，区别详解 - 慕课网</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">进程间通信 - 维基百科</a></p>
<p>还有网上很多文章</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/07/29/apns_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/07/29/apns_summary/" itemprop="url">APNS原理总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-29T21:51:44+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是APNs"><a href="#什么是APNs" class="headerlink" title="什么是APNs"></a>什么是APNs</h3><p>先说一下远程推送，一般我们有自己的服务器，在这个过程中是Provider的角色，如图，推送从我们的服务器到我们的APP的过程就是要通过APNs来发送</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-29_10:34:17.jpg" alt="2016-07-29_10:34:17.jpg"></p>
<p>APNs(Apple Push Notification service)是远程推送功能的核心，通过APNs客户端和苹果服务器建立一个长连接，推送也是通过这个长连接发送到客户端上</p>
<h3 id="deviceToken"><a href="#deviceToken" class="headerlink" title="deviceToken"></a>deviceToken</h3><p>deviceToken是设备的一个标识符，属于你这款APP装在你这个设备上的标识符，即每个APP在每一个不同的设备上都有着不同的deviceToekn，通过注册远程推送服务，APNs会返回给你的APP的deviceToken，如图</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-29_09:22:33.jpg" alt="2016-07-29_09:22:33.jpg"></p>
<p>在项目的AppDelegate里面有一个方法，如果成功注册了便可以接收到deviceToken</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br></pre></td></tr></table></figure>
<p>deviceToken不是唯一确定的，当你的设备更新了系统然后deviceToken就会改变</p>
<h3 id="安全架构"><a href="#安全架构" class="headerlink" title="安全架构"></a>安全架构</h3><p>为了保证安全性，APNs用连接信任(connection trust)和token信任(token trust)来控制通信入口，你要用APNs则必须用通过这两种验证。</p>
<h4 id="连接信任"><a href="#连接信任" class="headerlink" title="连接信任"></a>连接信任</h4><p>连接信任第一个作用是保证APNs连接的provider是苹果已经同意可通信的，然后第二个是保证与APNs连接的设备的合法性，第二步是APNs处理的，你所要处理的是provider与APNs之间的连接安全性。</p>
<h5 id="服务器与APNs之间的连接信任"><a href="#服务器与APNs之间的连接信任" class="headerlink" title="服务器与APNs之间的连接信任"></a>服务器与APNs之间的连接信任</h5><p>每个服务器都必须要有唯一的provider证书和私钥，都是用来验证连接的。provider证书就是在开发者官网申请的。</p>
<p>服务器通过TLS验证和APNs连接，HTTPS中用的也是TLS协议，即四步握手，首先初始化TLS连接，即provider(服务器)发送请求给APNs，APNs服务器返回APNs证书（即公钥）给provider，然后服务端收到后生成provider证书后再返回给APNs，APNs收到后验证后即可以建立TLS连接，不过APNs用的不是HTTPS，而是HTTP/2，具体过程如下图</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-29_22:13:00.jpg" alt="2016-07-29_22:13:00.jpg"></p>
<h5 id="APNs与设备之间的连接信任"><a href="#APNs与设备之间的连接信任" class="headerlink" title="APNs与设备之间的连接信任"></a>APNs与设备之间的连接信任</h5><p>设备和provider一样，都有私钥和设备证书，当设备激活了就保存在钥匙串(keychain)中，但是这部分的连接信任你是不用管的，由APNs负责，也是通过TLS来验证，过程和provider和APNs相同</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-29_23:35:06.jpg" alt="2016-07-29_23:35:06.jpg"></p>
<h4 id="Token信任"><a href="#Token信任" class="headerlink" title="Token信任"></a>Token信任</h4><p>Token信任就是保证通知从合法的起点推送到合法的终点，Token信任即要用到上面说的deviceToken，deviceToken提供给provider，然后之后你的provider每次发送要推送的通知都要携带deviceToken，这就是token信任</p>
<p>APNs会用token钥匙去保证通知来源（即你的服务器）的合法性，用包含在deviceTokenl里面的device ID去确定目标设备的身份，过程如下图</p>
<p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-29_23:41:02.jpg" alt="2016-07-29_23:41:02.jpg"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>图全部来自官方文档，很多关键词都是我自行翻译</p>
<p>苹果官方文档-Apple Push Notification Service</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ascen.me/blog/blog/2016/07/15/c_sort_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ascen Zhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ascen的羽毛">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2016/07/15/c_sort_algorithm/" itemprop="url">常见排序算法C++总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-15T20:45:44+08:00">
                2016-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-排序算法"><a href="#C-排序算法" class="headerlink" title="C++排序算法"></a>C++排序算法</h2><p>看了总结图，我这里就总结一下 直接插入排序，冒泡排序，快速排序，堆排序和归并排序，使用C++实现</p>
<p>重新画了总结图<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="2016-07-15_常用排序算法.png"></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>整个序列分为有序区和无序区，取第一个元素作为初始有序区，然后第二个开始，依次插入到有序区的合适位置，直到排好序</p>
<p>刚开始在我那本《数据结构》看到大概这样的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(int arr[], int len) &#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int temp;</span><br><span class="line">    for (i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp;j--)</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">        arr[j + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点难理解，后来又在网上看到这样的实现，这种方式比较好理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(int arr[],int n)&#123;</span><br><span class="line">    for (int i =1;i &lt;= n;++i)&#123;</span><br><span class="line">        for(int j = i;j &gt; 0;--j)&#123;</span><br><span class="line">            if(arr[j] &lt; arr[j -1])&#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - 1];</span><br><span class="line">                arr[j - 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理都是一样的，第一个for循环对从第二个开始的所有的数字遍历，嵌套的for循环是每次遍历数字时都取无序区的一个元素与有序区的元素比较，如果比有序区的要小则交换，直到合适的位置。</p>
<p>如果使用vector的话会方便一点，因为vector可以使用size()直接获得容器内的元素个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort2(vector&lt;int&gt; &amp;num)&#123;</span><br><span class="line">    for(int i = 1;i &lt; num.size();++i)&#123;</span><br><span class="line">        for(int j = i;j &gt; 0;--j)&#123;</span><br><span class="line">            if(num[j] &lt; num[j - 1])&#123;</span><br><span class="line">                int temp = num[j];</span><br><span class="line">                num[j] = num[j-1];</span><br><span class="line">                num[j-1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序的时间复杂度最好的情况是已经是正序的序列，只需比较(n-1)次，时间复杂度为O(n)，最坏的情况是倒序的序列，要比较n(n-1)/2次，时间复杂度为O(n^2 ) ，平均的话要比较时间复杂度为O(n^2 )</p>
<p>插入排序是一种稳定的排序方法，排序元素比较少的时候很好，大量元素便会效率低下</p>
<p>这个图很形象，取自维基百科<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-14_Insertion_sort_animation.gif" alt="2016-07-14_Insertion_sort_animation.gif"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>比较相邻的元素，如果反序则交换，过程也是分为有序区和无序区，初始时有序区为空，所有元素都在无序区，经过第一趟后就能找出最大的元素，然后重复便可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int arr[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序感觉非常好理解，第一个for循环是遍历所有元素，第二个for循环是每次遍历元素时都对无序区的相邻两个元素进行一次比较，若反序则交换</p>
<p>时间复杂度最坏的情况是反序序列，要比较n(n-1)/2次，时间复杂度为O(n^2 )，最好的情况是正序，只进行(n-1)次比较，不需要移动，时间复杂度为O(n)，而平均的时间复杂度为O(n^2 )</p>
<p>但是还有更好的方法，如果第一次比较完没有交换即说明已经有序，不应该进行下一次遍历<br>还有已经遍历出部分有序的序列后，那部分也不用进行遍历，即发生交换的地方之后的地方不用遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int arr[], int len)&#123;</span><br><span class="line">    int i,temp;</span><br><span class="line">	//记录位置，当前所在位置和最后发生交换的地方</span><br><span class="line">	int current,last = len - 1;</span><br><span class="line">	while(last &gt; 0) &#123;</span><br><span class="line">		for(i = current = 0;i &lt; last;++i)&#123;</span><br><span class="line">			if(arr[i] &gt; arr[i+1])&#123;</span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[i+1];</span><br><span class="line">				arr[i+1] = temp;</span><br><span class="line">				//记录当前的位置，如果没有发生交换current值即for循环初始化的0</span><br><span class="line">				current = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//若current = 0即已经没有可以交换的元素了，即已经有序了</span><br><span class="line">		last = current;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图取自维基<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-14_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="2016-07-14_冒泡排序.gif"></p>
<p>冒泡排序也是一种稳定的排序算法，也是元素较少时效率比较高</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序首先选一个轴值(pivot，也有叫基准的)，将待排序记录划分成独立的两部分，左侧的元素均小于轴值，右侧的元素均大于或等于轴值，然后对这两部分再重复，直到整个序列有序</p>
<p>过程是和二叉搜索树相似，就是一个递归的过程</p>
<p>排序函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(int arr[], int first, int end)&#123;</span><br><span class="line">	int pivot = OnceSort(arr,first,end);</span><br><span class="line">	//已经有轴值了，再对轴值左右进行递归</span><br><span class="line">	QuickSort(arr,first,pivot-1);</span><br><span class="line">	QuickSort(arr,pivot+1,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是一次排序的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void OnceSort(int arr[], int first, int end)&#123;</span><br><span class="line">	int i = first,j = end;</span><br><span class="line">	//当i&lt;j即移动的点还没到中间时循环</span><br><span class="line">	while(i &lt; j)&#123;</span><br><span class="line">		//右边区开始，保证i&lt;j并且arr[i]小于或者等于arr[j]的时候就向左遍历</span><br><span class="line">		while(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) --j;</span><br><span class="line">		//这时候已经跳出循环，说明j&gt;i 或者 arr[i]大于arr[j]了，如果i&lt;j那就是arr[i]大于arr[j]，那就交换</span><br><span class="line">		if(i &lt; j)&#123;</span><br><span class="line">			int temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		//对另一边执行同样的操作</span><br><span class="line">		while(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) ++i;</span><br><span class="line">		if(i &lt; j)&#123;</span><br><span class="line">			int temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	//返回已经移动的一边当做下次排序的轴值</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程解释都写在注释里面了，挺好理解的<br>这是我在书上看到的实现，用的是递归的方法<br>我在维基上还看到用迭代的方法，这里就不说了，有兴趣的可以去看看</p>
<p>这个图不是一般的棒！！来自维基<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-14_Sorting_quicksort_anim.gif" alt="2016-07-14_Sorting_quicksort_anim.gif"></p>
<p>快速排序时间复杂度的最好情况和平均情况一样为O(nlog2 n)，最坏情况下为O(n^2 )，这个看起来比前面两种排序都要好，但是这是不稳定的算法，并且空间复杂度高一点（ O(nlog2 n)<br>而且快速排序适用于元素多的情况</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆的结构类似于完全二叉树，每个结点的值都小于或者等于其左右孩子结点的值，或者每个节点的值都大于或等于其左右孩子的值</p>
<p>堆排序过程将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序</p>
<p>来看一下实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//堆排序</span><br><span class="line">void HeapSort(int arr[],int len)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    //初始化堆，从最后一个父节点开始</span><br><span class="line">    for(i = len/2 - 1; i &gt;= 0; --i)&#123;</span><br><span class="line">        Heapify(arr,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">    //从堆中的取出最大的元素再调整堆</span><br><span class="line">    for(i = len - 1;i &gt; 0;--i)&#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[0];</span><br><span class="line">        arr[0] = temp;</span><br><span class="line">        //调整成堆</span><br><span class="line">        Heapify(arr,0,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看 调整成堆的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Heapify(int arr[], int first, int end)&#123;</span><br><span class="line">    int father = first;</span><br><span class="line">    int son = father * 2 + 1;</span><br><span class="line">    while(son &lt; end)&#123;</span><br><span class="line">        if(son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son+1]) ++son;</span><br><span class="line">        //如果父节点大于子节点则表示调整完毕</span><br><span class="line">        if(arr[father] &gt; arr[son]) break;</span><br><span class="line">        else &#123;</span><br><span class="line">        	//不然就交换父节点和子节点的元素</span><br><span class="line">            int temp = arr[father];</span><br><span class="line">            arr[father] = arr[son];</span><br><span class="line">            arr[son] = temp;</span><br><span class="line">            //父和子节点变成下一个要比较的位置</span><br><span class="line">            father = son;</span><br><span class="line">            son = 2 * father + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序的时间复杂度最好到最坏都是O(nlogn)，较多元素的时候效率比较高</p>
<p>图来自维基<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="2016-07-15_堆排序.gif"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的基本思想是将若干个序列进行两两归并，直至所有待排序记录都在一个有序序列为止</p>
<p>这个图很有概括性，来自维基<br><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="2016-07-15_归并排序.gif"></p>
<p>我们也可以用递归的思想，每次合并就是一次递归<br>首先，将一整个序列分成两个序列，两个会分成4个，这样分下去分到最小单位，然后开始合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Merge(int arr[], int reg[], int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end)return;</span><br><span class="line">    int len = end - start, mid = (len &gt;&gt; 1) + start;</span><br><span class="line"></span><br><span class="line">    //分成两部分</span><br><span class="line">    int start1 = start, end1 = mid;</span><br><span class="line">    int start2 = mid + 1, end2 = end;</span><br><span class="line">    //然后递归，分成更小的序列</span><br><span class="line">    Merge(arr, reg, start1, end1);</span><br><span class="line">    Merge(arr, reg, start2, end2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int k = start;</span><br><span class="line">    //两个序列一一比较,哪的序列的元素小就放进reg序列里面,然后位置+1再与另一个序列原来位置的元素比较</span><br><span class="line">    //如此反复,可以把两个有序的序列合并成一个有序的序列</span><br><span class="line">    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    </span><br><span class="line">    //然后这里是分情况,如果arr2序列的已经全部都放进reg序列了然后跳出了循环</span><br><span class="line">    //那就表示arr序列还有更大的元素(一个或多个)没有放进reg序列,所以这一步就是接着放</span><br><span class="line">    while (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    </span><br><span class="line">    //这一步和上面一样</span><br><span class="line">    while (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    //把已经有序的reg序列放回arr序列中</span><br><span class="line">    for (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(int arr[], const int len) &#123;</span><br><span class="line">    //创建一个同样长度的序列,用于临时存放</span><br><span class="line">    int  reg[len];</span><br><span class="line">    Merge(arr, reg, 0, len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程解释都写在了注释里</p>
<p>归并排序的时间复杂度都是O(nlogn)，并且适用于元素较多的时候排序</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>1 《数据结构(C++版)》</li>
<li>2 维基百科</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ascen Zhong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/归档">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ascen Zhong</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
